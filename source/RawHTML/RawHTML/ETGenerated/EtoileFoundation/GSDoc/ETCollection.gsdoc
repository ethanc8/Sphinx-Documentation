<?xml version="1.0"?>
<!DOCTYPE gsdoc PUBLIC "-//GNUstep//DTD gsdoc 1.0.4//EN" "http://www.gnustep.org/gsdoc-1_0_4.dtd">
<gsdoc base="ETCollection">
  <head>
    <title>ETCollection documentation</title>
    <author name="Generated by pi"></author>
    <copy>2007 Quentin Mathe</copy>
  </head>
  <body>
    <front><contents /></front>
    <chapter>
      <heading>
        Software documentation for the ETCollectionTrait class
      </heading>
      <class name="ETCollectionTrait" super="NSObject">
        <declared>ETCollection.h</declared>
        <conform>ETCollection</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract A basic and
            reusable ETCollection implementation.
          </p>
          <p>
            This trait implements all ETCollection protocol
            methods, except
            <ref type="method" id="-content">
              -content
            </ref>
            and
            <ref type="method" id="-contentArray">
              -contentArray
            </ref>
            , for which concrete implementations must be provided by
            the target class.
          </p>
          <p>
            Any method provided by ETCollectionTrait can be
            overriden by implementing the method in the
            target class.
          </p>
          <p>
            Here is a simple example that implements a complete
            mutable collection API. In addition to
            ETCollectionTrait, it also leverages
            ETMutableCollectionTrait to do so.
          </p>
<example>
@interface MyCollection : NSObject &gt;ETCollection, ETCollectionMutation&lt;
{
    NSMutableArray *things;
}

@end

@implementation

+ (void) initialize
{
    if (self != [MyCollection class])
        return;

    [self applyTraitFromClass: [ETCollection class]];
    [self applyTraitFromClass: [ETMutableCollection class]];
}

// Omitted initialization and deallocation methods

- (id) content
{
    return things;
}

- (NSArray *) contentArray
{
    return [NSArray arrayWithArray: things];
}

- (void) insertObject: (id)object atIndex: (NSUInteger)index hint: (id)hint
{
    if (index == ETUndeterminedIndex)
    {
        [things addObject: object];
    }
    else
    {
        [things insertObject: object atIndex: index];
    }
}

- (void) removeObject: (id)object atIndex: (NSUInteger)index hint: (id)hint
{
    if (index == ETUndeterminedIndex)
    {
        [things removeObject: object];
    }
    else
    {
        [things removeObjectAtIndex: index];
    }
}

@end 
</example>
        </desc>
      </class>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        ETMutableCollectionTrait class
      </heading>
      <class name="ETMutableCollectionTrait" super="ETCollectionTrait">
        <declared>ETCollection.h</declared>
        <conform>ETCollectionMutation</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract A basic and
            reusable ETCollectionMutation implementation.
          </p>
          <p>
            This trait implements all ETCollectionMutation
            protocol methods, except
            <ref type="method" id="-insertObject:atIndex:hint:">
              -insertObject:atIndex:hint:
            </ref>
            and
            <ref type="method" id="-removeObject:atIndex:hint:">
              -removeObject:atIndex:hint:
            </ref>
            , for which concrete implementations must be provided by
            the target class.
          </p>
          <p>
            Any method provided by ETMutableCollectionTrait can be
            overriden by implementing the method in the
            target class.
          </p>
          <p>
            For a use case example, see ETCollectionTrait.
          </p>
        </desc>
      </class>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSArray(ETCollection)
        category
      </heading>
      <category name="ETCollection" class="NSArray">
        <declared>ETCollection.h</declared>
        <conform>ETCollection</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract ETCollection
            support for NSArray.
          </p>
        </desc>
        <method type="Class" factory="yes">
          <sel>mutableClass</sel>
          <desc>
            <p>
              Returns NSMutableDictionary class.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>content</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>contentArray</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="BOOL">
          <sel>isOrdered</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>viewpointArray</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSCountedSet(ETCollection) category
      </heading>
      <category name="ETCollection" class="NSCountedSet">
        <declared>ETCollection.h</declared>
        <desc>
          <p>
            @group Collection Protocols @abstract ETCollection
            support for NSCountedSet.
          </p>
          <p>
            NSCountedSet is a NSMutableSet subclass and
            thereby inherits the collection protocol methods
            implemented in NSSet(ETCollection).
          </p>
        </desc>
        <method type="Class" factory="yes">
          <sel>mutableClass</sel>
          <desc>
            <p>
              Returns self, the NSCountedSet class.
            </p>
            <p>
              NSCountedSet is always mutable and has not
              immutable equivalent.
            </p>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSDictionary(ETCollection) category
      </heading>
      <category name="ETCollection" class="NSDictionary">
        <declared>ETCollection.h</declared>
        <conform>ETKeyedCollection</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract ETCollection
            and ETKeyedCollection support for NSDictionary.
          </p>
        </desc>
        <method type="Class" factory="yes">
          <sel>mutableClass</sel>
          <desc>
            <p>
              Returns NSMutableDictionary class.
            </p>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>arrayRepresentation</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="id">
          <sel>content</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>contentArray</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="BOOL">
          <sel>isKeyed</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>viewpointArray</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSIndexSet(ETCollection) category
      </heading>
      <category name="ETCollection" class="NSIndexSet">
        <declared>ETCollection.h</declared>
        <conform>ETCollection</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract ETCollection
            support for NSIndexSet.
          </p>
        </desc>
        <method type="Class" factory="yes">
          <sel>mutableClass</sel>
          <desc>
            <p>
              Returns NSMutableIndexSet class.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>content</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>contentArray</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="NSEnumerator*">
          <sel>objectEnumerator</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSMutableArray(ETCollectionMutation)
        category
      </heading>
      <category name="ETCollectionMutation" class="NSMutableArray">
        <declared>ETCollection.h</declared>
        <conform>ETCollectionMutation</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract
            ETCollectionMutation support for
            NSMutableArray.
          </p>
          <p>
            For NSMutableArray,
            <ref type="method" id="-insertObject:atIndex:">
              -insertObject:atIndex:
            </ref>
            raises an exception when the index is
            ETUndeterminedIndex.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSMutableDictionary(ETCollectionMutation)
        category
      </heading>
      <category name="ETCollectionMutation" class="NSMutableDictionary">
        <declared>ETCollection.h</declared>
        <conform>ETCollectionMutation</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract
            ETCollectionMutation support for
            NSMutableDictionary.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSMutableIndexSet(ETCollectionMutation)
        category
      </heading>
      <category name="ETCollectionMutation" class="NSMutableIndexSet">
        <declared>ETCollection.h</declared>
        <conform>ETCollectionMutation</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract
            ETCollectionMutation support for
            NSMutableIndexSet.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSMutableOrderedSet(ETCollectionMutation)
        category
      </heading>
      <category name="ETCollectionMutation" class="NSMutableOrderedSet">
        <declared>ETCollection.h</declared>
        <conform>ETCollectionMutation</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract
            ETCollectionMutation support for
            NSMutableOrderedSet.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSMutableSet(ETCollectionMutation)
        category
      </heading>
      <category name="ETCollectionMutation" class="NSMutableSet">
        <declared>ETCollection.h</declared>
        <conform>ETCollectionMutation</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract
            ETCollectionMutation support for
            NSMutableSet.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSObject(ETBatchCollectionMutation)
        informal protocol
      </heading>
      <category name="ETBatchCollectionMutation" class="NSObject">
        <declared>ETCollection.h</declared>
        <desc>
          <p>
            @group Collection Protocols @abstract Optional batch
            mutation protocol methods for
            ETCollectionMutation.
          </p>
          <p>
            Any mutable collection can also implement the optional
            methods listed below.
          </p>
          <p>
            EtoileUI will use these methods when possible.
            <br /> Initially you can skip implementing them.
            Later, they can be implemented to speed up the
            communication between your model collections
            and the layout items that represent them at the UI
            level. In addition, these methods allows to react to
            batch insertion and removal at the model level (e.g.
            in reply to a pick and drop).
          </p>
          <p>
            You are not required to implement every method when a
            class adopts this informal protocol.
          </p>
          <p>
            When a collection is received in argument, the
            collection type can be checked to know whether
            the code needs to convert the collection or not, to
            remove or insert its content in the receiver. In
            most cases, the code below is a useless optimization
            (the else branch is good enough).
          </p>
<example>
if ([[aCollection content] isArray] == NO)
{
    [personIvarArray addObjectsFromArray: (NSArray *)aCollection];
}
else
{
    [personIvarArray addObjectsFromArray: [aCollection contentArray]];
}
</example>
          <p>
            See NSObject+Model for other methods such as
            <ref type="method" id="-isArray">
              -isArray
            </ref>
            .
          </p>
        </desc>
        <method type="void">
          <sel>insertCollection:</sel>
          <arg type="id&lt;ETCollection&gt;">objects</arg>
          <sel>atIndexes:</sel>
          <arg type="NSIndexSet*">indexes</arg>
          <desc>
            <p>
              Inserts the given collection elements at separate
              <var>indexes</var>.
            </p>
            <p>
              When the collection is not ordered, the
              <var>indexes</var> are ignored.
            </p>
            <p>
              The element are inserted one-by-one by increasing
              index value while iterating over the
              <var>indexes</var>. When the greatest index is
              reached and several elements remain to be
              inserted, they are inserted at that same index.
              <br /> For a more precise description of the
              behavior ordered collection should comply to,
              see -[NSArray insertObjects:atIndexes:] in Cocoa
              documentation.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>removeObjectAtIndexes:</sel>
          <arg type="NSIndexSet*">indexes</arg>
          <desc>
            <p>
              Removes the elements at the given
              <var>indexes</var> from the collection.
            </p>
            <p>
              You should only implement this method when the
              collection is ordered.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>removesCollection:</sel>
          <arg type="id&lt;ETCollection&gt;">objects</arg>
          <desc>
            <p>
              Removes the elements from the collection.
            </p>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSObject(ETCollectionMutationKVOSupport)
        category
      </heading>
      <category name="ETCollectionMutationKVOSupport" class="NSObject">
        <declared>ETCollection.h</declared>
        <desc>
          <p>
            @group Collection Protocols @abstract Unified
            protocol to post key-value observing change
            notifications for any collections that
            conform to ETCollection.
          </p>
          <p>
            This lets you easily change the collection type,
            without rewriting all the mutation notifications.
          </p>
        </desc>
        <method type="void">
          <sel>didChangeValueForKey:</sel>
          <arg type="NSString*">key</arg>
          <sel>atIndexes:</sel>
          <arg type="NSIndexSet*">indexes</arg>
          <sel>withObjects:</sel>
          <arg type="NSArray*">objects</arg>
          <sel>mutationKind:</sel>
          <arg type="ETCollectionMutationKind">mutationKind</arg>
          <desc>
            <p>
              Tells the receiver that the collection bound to the
              property is about to change.
            </p>
            <p>
              By default, limited to calling:
            </p>
            <deflist>
              <term>
                <ref type="method" id="-didChangeValueForKey:">
                  -didChangeValueForKey:
                </ref>
              </term>
              <desc>
                NSDictionary, NSMapTable and NSIndexSet
              </desc>
              <term>
                <ref type="method" id="-didChange:valuesAtIndexes:forKey:">-didChange:valuesAtIndexes:forKey:</ref>
              </term>
              <desc>
                NSArray, NSPointerArray and NSOrderedSet
              </desc>
              <term>
                <ref type="method" id="-didChangeValueForKey:withSetMutation:usingObjects:">-didChangeValueForKey:withSetMutation:usingObjects:</ref>
              </term>
              <desc>NSSet and NSHashTable</desc>
            </deflist>
            <p>
              For an ordered collection, the correct index must be
              passed for each inserted or removed object,
              otherwise a NSInvalidArgumentException is
              raised.
            </p>
            <p>
              For an unordered collection, the <var>indexes</var>
              should be empty.
            </p>
            <p>
              For <code>nil</code> arguments, raises a
              NSInvalidArgumentException.
            </p>
            <p>
              Can be overriden, but the superclass implementation
              must be called.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>willChangeValueForKey:</sel>
          <arg type="NSString*">key</arg>
          <sel>atIndexes:</sel>
          <arg type="NSIndexSet*">indexes</arg>
          <sel>withObjects:</sel>
          <arg type="NSArray*">objects</arg>
          <sel>mutationKind:</sel>
          <arg type="ETCollectionMutationKind">mutationKind</arg>
          <desc>
            <p>
              Tells the receiver that the collection bound to the
              property is about to change.
            </p>
            <p>
              By default, limited to calling:
            </p>
            <deflist>
              <term>
                <ref type="method" id="-willChangeValueForKey:">
                  -willChangeValueForKey:
                </ref>
              </term>
              <desc>
                NSDictionary, NSMapTable and NSIndexSet
              </desc>
              <term>
                <ref type="method" id="-willChange:valuesAtIndexes:forKey:">-willChange:valuesAtIndexes:forKey:</ref>
              </term>
              <desc>
                NSArray, NSPointerArray and NSOrderedSet
              </desc>
              <term>
                <ref type="method" id="-willChangeValueForKey:withSetMutation:usingObjects:">-willChangeValueForKey:withSetMutation:usingObjects:</ref>
              </term>
              <desc>NSSet and NSHashTable</desc>
            </deflist>
            <p>
              For an ordered collection, the correct index must be
              passed for each inserted or removed object,
              otherwise a NSInvalidArgumentException is
              raised.
            </p>
            <p>
              For an unordered collection, the <var>indexes</var>
              should be empty.
            </p>
            <p>
              For <code>nil</code> arguments, raises a
              NSInvalidArgumentException.
            </p>
            <p>
              Can be overriden, but the superclass implementation
              must be called.
            </p>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSOrderedSet(ETCollection) category
      </heading>
      <category name="ETCollection" class="NSOrderedSet">
        <declared>ETCollection.h</declared>
        <conform>ETCollection</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract ETCollection
            support for NSOrderedSet.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSSet(ETCollection)
        category
      </heading>
      <category name="ETCollection" class="NSSet">
        <declared>ETCollection.h</declared>
        <conform>ETCollection</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract ETCollection
            support for NSSet.
          </p>
        </desc>
        <method type="Class" factory="yes">
          <sel>mutableClass</sel>
          <desc>
            <p>
              Returns NSMutableSet class.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>content</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>contentArray</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>viewpointArray</sel>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the ETCollection protocol
      </heading>
      <protocol name="ETCollection">
        <declared>ETCollection.h</declared>
        <conform>NSObject</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract Unified
            protocol to interact with collections.
          </p>
          <p>
            Basic collection protocol that all collections must
            support. EtoileFoundation extends Foundation
            classes such as NSArray, NSDictionary, NSSet and
            NSIndexSet to adopt this protocol. EtoileUI
            extends NSView in the same way.
          </p>
          <p>
            With this protocol, the collection content can be
            accessed and queried in various ways but cannot be
            mutated.
          </p>
          <p>
            Given most protocol method implementations remains
            the same accross collection classes, we provide
            ETCollectionTrait as a reusable
            ETCollection implementation.
          </p>
          <p>
            The two primitives methods are
            <ref type="method" id="-content">
              -content
            </ref>
            and
            <ref type="method" id="-contentArray">
              -contentArray
            </ref>
            . These methods must be implemented in the collection
            class in all cases. See ETCollectionTrait.
          </p>
          <p>
            When you write a new class that includes a to-many
            relationship, it should conform to
            ETCollection. If several to-many
            relationships exist, you should pick the
            dominant relationship that best represents the
            main content. A good hint is to pick the most
            recurrent way to browse the content with a UI,
            and the relationship traversed in such a case. <br />
            EtoileUI can automatically present collection-like
            content and support navigation into it when
            represented objects bound to ETLayoutItemGroup
            conform to ETCollection.
          </p>
          <p>
            Note: In future, we will provide a viewpoint
            mechanism to view or traverse objects through
            their non-dominant to-many relationships.
          </p>
        </desc>
        <method type="BOOL">
          <sel>containsCollection:</sel>
          <arg type="id&lt;ETCollection&gt;">objects</arg>
          <desc>
            <p>
              Returns whether every element in the given
              collection are included in the receiver.
            </p>
          </desc>
        </method>
        <method type="BOOL">
          <sel>containsObject:</sel>
          <arg type="id">anObject</arg>
          <desc>
            <p>
              Returns whether the element is included in the
              collection.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>content</sel>
          <desc>
            <p>
              Returns the underlying data structure object
              holding the content or self when the protocol is
              adopted by a class which is a content data
              structure by itself (like NSArray,
              NSDictionary, NSSet etc.).
            </p>
            <p>
              Content by its very nature is always a collection
              of other objects. As such, content may hold one or no
              objects (empty collection).
            </p>
            <p>
              When adopted, this method must never return
              <code>nil</code>.
            </p>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>contentArray</sel>
          <desc>
            <p>
              Returns the content as a new NSArray-based
              collection of objects.
            </p>
            <p>
              When adopted, this method must never return
              <code>nil</code>, you should generally return an
              empty NSArray instead.
            </p>
          </desc>
        </method>
        <method type="NSUInteger">
          <sel>count</sel>
          <desc>
            <p>
              Returns the number of elements hold by the
              receiver.
            </p>
          </desc>
        </method>
        <method type="NSUInteger">
          <sel>countByEnumeratingWithState:</sel>
          <arg type="NSFastEnumerationState*">state</arg>
          <sel>objects:</sel>
          <arg type="id*">objects</arg>
          <sel>count:</sel>
          <arg type="NSUInteger">count</arg>
          <desc>
            <p>
              Returns a C array through <var>objects</var>
              which can be used to iterate over the content in
              several quick passes until 0 is returned.
            </p>
            <p>
              Each time the method is called, the C array contains
              a new content portion to be iterated over.
            </p>
            <p>
              The method returns the number of <var>objects</var>
              in the C array.
            </p>
            <p>
              The <var>count</var> argument must be used to
              indicate the maximum number of
              <var>objects</var> allowed in the C array to be
              returned.
            </p>
            <p>
              See NSFastEnumeration protocol.
            </p>
          </desc>
        </method>
        <method type="BOOL">
          <sel>isEmpty</sel>
          <desc>
            <p>
              Returns <code>YES</code> when the collection
              contains no elements, otherwise returns
              <code>NO</code>.
            </p>
          </desc>
        </method>
        <method type="BOOL">
          <sel>isKeyed</sel>
          <desc>
            <p>
              Returns whether the receiveir stores the elements
              by key.
            </p>
            <p>
              If the receivers returns <code>YES</code>, it must
              implement
              <ref type="method" id="-arrayRepresentation">
                -arrayRepresentation
              </ref>
              . <br />
              <ref type="method" id="-arrayRepresentation">
                -arrayRepresentation
              </ref>
              must return the content as a key-value pair array.
            </p>
          </desc>
        </method>
        <method type="NSEnumerator*">
          <sel>objectEnumerator</sel>
          <desc>
            <p>
              Returns an enumerator which can be used as a
              conveniency to iterate over the elements of
              the content one-by-one.
            </p>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>viewpointArray</sel>
          <desc>
            <p>
              Returns the collection represented as viewpoints
              on the collection elements.
            </p>
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the ETCollectionMutation
        protocol
      </heading>
      <protocol name="ETCollectionMutation">
        <declared>ETCollection.h</declared>
        <desc>
          <p>
            @group Collection Protocols @abstract Unified
            protocol to mutate collections.
          </p>
          <p>
            Additional collection protocol that all mutable
            collections must support. EtoileFoundation
            extends Foundation classes such as NSMutableArray,
            NSMutableDictionary, NSMutableSet,
            NSCountedSet and NSMutableIndexSet to adopt
            this protocol. EtoileUI extends NSView in the same
            way.
          </p>
          <p>
            Given most protocol method implementations remains
            the same accross collection classes, we provide
            ETMutableCollectionTrait as a
            reusable ETCollectionMutation implementation.
          </p>
          <p>
            The two primitive methods are
            <ref type="method" id="-insertObject:atIndex:hint:">
              -insertObject:atIndex:hint:
            </ref>
            and
            <ref type="method" id="-removeObject:atIndex:hint:">
              -removeObject:atIndex:hint:
            </ref>
            . These methods must be implemented in the collection
            class in all cases. See ETMutableCollectionTrait.
          </p>
          <p>
            When you write a new class that includes a mutable
            to-many relationship, it should conform to
            ETCollectionMutation, based on the
            rules presented in ETCollection documentation. <br />
            EtoileUI can automatically mutate collection-like
            content and support turning user actions (e.g. drag
            an drop) into collection operations, when represented
            objects bound to ETLayoutItemGroup conform to
            ETCollectionMutation in addition to
            ETCollection.
          </p>
        </desc>
        <method type="void">
          <sel>insertObject:</sel>
          <arg type="id">object</arg>
          <sel>atIndex:</sel>
          <arg type="NSUInteger">index</arg>
          <desc>
            <p>
              Inserts the element at the given <var>index</var>
              in the collection.
            </p>
            <p>
              A collection can raise an exception on a
              <code>nil</code> <var>object</var>. <br /> An
              ordered collection can raise an exception on an
              invalid <var>index</var> such as
              ETUndeterminedIndex (this is not the
              same behavior than -insertObject:atIndex:hint:).
            </p>
            <p>
              When the collection is not ordered, the
              <var>index</var> is ignored and the behavior is the
              same than
              <ref type="method" id="-addObject:">
                -addObject:
              </ref>
              .
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>insertObject:</sel>
          <arg type="id">object</arg>
          <sel>atIndex:</sel>
          <arg type="NSUInteger">index</arg>
          <sel>hint:</sel>
          <arg type="id">hint</arg>
          <desc>
            <p>
              Inserts the element at the given <var>index</var>
              in the collection, by making adjustments based on the
              <var>hint</var> if needed.
            </p>
            <p>
              The element to be inserted must never be
              <code>nil</code>. The collection can raise an
              exception in such case.
            </p>
            <p>
              If the collection is not ordered, the <var>index</var>
              can be ignored (the insertion becomes an addition),
              but otherwise it must not.
            </p>
            <p>
              If the <var>index</var> is ETUndeterminedIndex, the
              insertion must be treated as an addition and
              the <var>object</var> inserted in last position if
              the collection is ordered e.g. NSMutableArray. See
              also
              <ref type="method" id="-addObject:">
                -addObject:
              </ref>
              .
            </p>
            <p>
              If the <var>hint</var> is not <code>nil</code>, the
              collection can test the <var>hint</var> type.
              If the <var>hint</var> matches its expectation, it's
              up to the collection to choose another
              <var>index</var> and/or another element to insert.
              Both the custom <var>index</var> and element can be
              provided by the <var>hint</var>. <br /> The
              collection must continue to behave in a
              predictable way (as detailed above) when no
              <var>hint</var> is provided.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>insertObjects:</sel>
          <arg type="NSArray*">objects</arg>
          <sel>atIndexes:</sel>
          <arg type="NSIndexSet*">indexes</arg>
          <sel>hints:</sel>
          <arg type="NSArray*">hints</arg>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="void">
          <sel>removeObject:</sel>
          <arg type="id">object</arg>
          <desc>
            <p>
              Removes the element from the collection.
            </p>
            <p>
              A collection can raise an exception on a
              <code>nil</code> <var>object</var>.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>removeObject:</sel>
          <arg type="id">object</arg>
          <sel>atIndex:</sel>
          <arg type="NSUInteger">index</arg>
          <sel>hint:</sel>
          <arg type="id">hint</arg>
          <desc>
            <p>
              Removes the element at the given <var>index</var>
              from the collection, by making adjustments based on
              the <var>hint</var> if needed.
            </p>
            <p>
              The element can be <code>nil</code>, but then the
              <var>index</var> must not be ETUndeterminedIndex.
              Otherwise the collection can raise an
              exception.
            </p>
            <p>
              If the collection is not ordered, the <var>index</var>
              can be ignored, but otherwise it must not.
            </p>
            <p>
              If the <var>index</var> is ETUndeterminedIndex, all
              occurences of the element must be removed from
              the collection.
            </p>
            <p>
              If both the element and <var>index</var> are valid,
              the element should be ignored and priority must be
              given to the <var>index</var> to locate the objects
              to remove (this rule is subject to change a bit).
            </p>
            <p>
              If the <var>hint</var> is not <code>nil</code>, the
              collection can test the <var>hint</var> type.
              If the <var>hint</var> matches its expectation, it's
              up to the collection to choose another
              <var>index</var> and/or another element to remove.
              Both the custom <var>index</var> and element can be
              provided by the <var>hint</var>. <br /> The
              collection must continue to behave in a
              predictable way (as detailed above) when no
              <var>hint</var> is provided. <br /> If the
              <var>hint</var> can provide both a custom element
              and <var>index</var>, as stated previously, priority
              must be given to the <var>index</var> to locate the
              objects to remove.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>removeObjectAtIndex:</sel>
          <arg type="NSUInteger">index</arg>
          <desc>
            <p>
              Removes the element at the given <var>index</var>
              from the collection.
            </p>
            <p>
              An ordered collection can raise an exception on an
              invalid <var>index</var> such as
              ETUndeterminedIndex.
            </p>
            <p>
              When the collection is not ordered, an exception
              should be raised.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>removeObjects:</sel>
          <arg type="NSArray*">objects</arg>
          <sel>atIndexes:</sel>
          <arg type="NSIndexSet*">indexes</arg>
          <sel>hints:</sel>
          <arg type="NSArray*">hints</arg>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
        <method type="void">
          <sel>validateMutationForObjects:</sel>
          <arg type="NSArray*">objects</arg>
          <sel>atIndexes:</sel>
          <arg type="NSIndexSet*">indexes</arg>
          <sel>hints:</sel>
          <arg type="NSArray*">hints</arg>
          <sel>isRemoval:</sel>
          <arg type="BOOL">isRemoval</arg>
          <desc>
            <em>Description forthcoming.</em>
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the ETKeyedCollection
        protocol
      </heading>
      <protocol name="ETKeyedCollection">
        <declared>ETCollection.h</declared>
        <conform>ETCollection</conform>
        <desc>
          <p>
            @group Collection Protocols @abstract Unified
            protocol to interact with collections composed of
            key-value pairs.
          </p>
        </desc>
        <method type="NSArray*">
          <sel>arrayRepresentation</sel>
          <desc>
            <p>
              Returns an ETKeyValuePair array where every entry
              present in the keyed collection is turned into a
              pair object.
            </p>
            <p>
              The returned array is autoreleased.
            </p>
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>ETCollection types</heading>
      <p></p>
      <type type="enum ..." name="ETCollectionMutationKind">
        <desc>
          <em>Description forthcoming.</em>
        </desc>
      </type>
    </chapter>
    <chapter>
      <heading>ETCollection constants</heading>
      <p></p>
      <constant type="const NSUInteger" name="ETUndeterminedIndex">
        <desc>
          <p>
            Marks an element which shouldn't be considered bound
            to a particular index in an ordered collection or whose
            index isn't yet determined. <br /> For use cases, see
            ETCollectionMutation.
          </p>
          <p>
            With EtoileUI, can be used to indicate a drop is not
            an insertion at precise index but a simple drop on.
          </p>
        </desc>
      </constant>
    </chapter>
  </body>
</gsdoc>
