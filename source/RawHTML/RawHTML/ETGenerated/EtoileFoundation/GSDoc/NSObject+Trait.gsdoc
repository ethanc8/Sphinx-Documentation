<?xml version="1.0"?>
<!DOCTYPE gsdoc PUBLIC "-//GNUstep//DTD gsdoc 1.0.4//EN" "http://www.gnustep.org/gsdoc-1_0_4.dtd">
<gsdoc base="NSObject+Trait">
  <head>
    <title>NSObject+Trait documentation</title>
    <author name="Generated by pi"></author>
    <copy>2007 David Chisnall, Quentin Mathe</copy>
  </head>
  <body>
    <front><contents /></front>
    <chapter>
      <heading>
        Software documentation for the NSObject(ETTrait)
        category
      </heading>
      <category name="ETTrait" class="NSObject">
        <declared>NSObject+Trait.h</declared>
        <desc>
          <p>
            @group Language Extensions @abstract Objective-C
            trait support.
          </p>
          <p>
            Adds traits to Objective-C, to support class
            composition, in addition to inheritance.
            Traits allow methods to be added to another class.
          </p>
          <p>
            The trait support in EtoileFoundation is based on:
          </p>
          <list>
            <item>
              http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf
              (original and <strong>short</strong> one)
            </item>
            <item>
              http://scg.unibe.ch/archive/papers/Duca06bTOPLASTraits.pdf (most recent and quite lengthy)
            </item>
          </list>
          <p>
            To get an introduction to the trait model and its
            various rules, you should read the
            <strong>short</strong> paper listed above.
          </p>
          <p>
            @section Objective-C Trait Overview and
            Restrictions
          </p>
          <p>
            The trait API supports both trait operators (exclusion,
            aliasing) and composite trait (a trait with
            subtraits). However there are two important
            restrictions:
          </p>
          <list>
            <item>
              the super keyword must not be used in a trait method
            </item>
            <item>
              instances variables must not be accessed
              directly but only through accessors
            </item>
          </list>
          <p>
            If these restrictions are ignored, the code may compile,
            but will surely result in a buggy behavior at runtime.
          </p>
          <p>
            With the current implementation, the limitations below
            should be kept in mind:
          </p>
          <list>
            <item>
              trait applications don't take in account class
              methods
            </item>
            <item>
              no mechanism to declare and check non-trait methods
              required by trait methods (so you get a runtime
              exception instead)
            </item>
          </list>
          <p>
            @section Basic example and Terminology
          </p>
          <p>
            To apply a trait, the basic API is
            <ref type="method" id="+applyTraitFromClass:">
              +applyTraitFromClass:
            </ref>
            , and we use the terminology below:
          </p>
          <deflist>
            <term>trait class</term>
            <desc>
              the class which represents a trait and whose methods
              are called trait methods. The superclass methods are
              ignored if the class is used as a trait
            </desc>
            <term>target class</term>
            <desc>
              the class to which a trait class is applied to
            </desc>
            <term>trait application</term>
            <desc>
              a trait use that involves a trait class, a target class
              and operator-related arguments
            </desc>
          </deflist>
          <p>
            For example:
          </p>
<example>
// Traits should be applied as early as possible usually, that's why we use +initialize
+ (void) initialize
{
    if (self != [MyClass class])
        return;

    [aTargetClass applyTraitFromClass: aTraitClass];
}
</example>
          <p>
            @section Detailed Examples
          </p>
          <p>
            Here is a more complex example that applies two
            subtraits (BasicTrait and ComplexTrait) to
            another trait (CompositeTrait), then the resulting
            is applied to the target class (the receiver's class).
          </p>
<example>
    // -wanderWhere: from Basic method will be renamed -lost: in CompositeTrait
    [[CompositeTrait class] applyTraitFromClass: [BasicTrait class]
                            excludedMethodNames: S(@"isOrdered")
                             aliasedMethodNames: D(@"lost:", @"wanderWhere:")];

    [[CompositeTrait class] applyTraitFromClass: [ComplexTrait class]];

    [[self class] applyTraitFromClass: [CompositeTrait class]];
</example>
          <p>
            As a concrete example, collection protocols are now
            implemented by most classes in Étoilé
            frameworks through two new ETCollectionTrait and
            ETMutableCollectionTrait.
          </p>
          <p>
            @section Trait Validation
          </p>
          <p>
            Trait applications are memorized to support composite
            traits and multiple trait applications to the same
            target class. Each time a trait is applied, it gets
            validated against the trait tree already bound to
            the target class. This ensures operators, overriding
            rule and flattening property will remain valid in the
            new trait tree. Unlike Squeak trait support, a trait
            can be applied at any time.
          </p>
          <p>
            @section Mixin-style Application
          </p>
          <p>
            In addition, it's possible to apply a trait without the
            overriding rule (that states target class
            overrides trait methods), which means methods in
            the target class can be replaced by methods from a
            trait.
          </p>
<example>
    // With YES, we allow the trait to override/replace methods in the target class
    [[self class] applyTraitFromClass: [BasicTrait class]
                  excludedMethodNames: S(@"isOrdered")
                   aliasedMethodNames: D(@"lost:", @"wanderWhere:")
                       allowsOverride: YES];
</example>
          <p>
            Trait applications are commutative, so the ordering
            in which you apply traits doesn't matter… but when this
            mixin-style composition is used, traits are not
            commutative and the ordering matters. That's
            why we'd rather discourage its use.
          </p>
        </desc>
        <method type="void" factory="yes">
          <sel>applyTraitFromClass:</sel>
          <arg type="Class">aClass</arg>
          <desc>
            <p>
              Apply <var>aClass</var> to this class as a trait.
            </p>
            <p>
              Raises exceptions if the trait application cannot
              be validated.
            </p>
          </desc>
        </method>
        <method type="void" factory="yes">
          <sel>applyTraitFromClass:</sel>
          <arg type="Class">aClass</arg>
          <sel>excludedMethodNames:</sel>
          <arg type="NSSet*">excludedNames</arg>
          <sel>aliasedMethodNames:</sel>
          <arg type="NSDictionary*">aliasedNames</arg>
          <desc>
            <p>
              Apply <var>aClass</var> to this class as a trait,
              without the trait methods listed in
              <var>excludedNames</var>, and by renaming the trait
              methods with the name values provided in the
              <var>aliasedNames</var> dictionary (where keys
              should be the existing trait method names).
            </p>
            <p>
              Raises exceptions if the trait application cannot
              be validated.
            </p>
          </desc>
        </method>
        <method type="void" factory="yes">
          <sel>applyTraitFromClass:</sel>
          <arg type="Class">aClass</arg>
          <sel>excludedMethodNames:</sel>
          <arg type="NSSet*">excludedNames</arg>
          <sel>aliasedMethodNames:</sel>
          <arg type="NSDictionary*">aliasedNames</arg>
          <sel>allowsOverride:</sel>
          <arg type="BOOL">override</arg>
          <desc>
            <p>
              Does the same than
              <ref type="method" id="+applyTraitFromClass:excludedMethodNames:aliasedMethodNames:">+applyTraitFromClass:excludedMethodNames:aliasedMethodNames:</ref> but allows to replace methods in the target class with trait methods if <code>YES</code> is passed as the last argument.
            </p>
            <p>
              By default, the trait overriding rule states that
              trait methods cannot replace methods that belongs
              to the target class, but only hide methods declared in
              superclasses and inherited by the target
              class.
            </p>
            <p>
              If <code>YES</code> is passed and there are other
              traits applied to the target class, the ordering
              use to apply traits cannot be ignored anymore.
            </p>
            <p>
              Raises exceptions if the trait application cannot
              be validated.
            </p>
          </desc>
        </method>
      </category>
    </chapter>
  </body>
</gsdoc>
