<?xml version="1.0"?>
<!DOCTYPE gsdoc PUBLIC "-//GNUstep//DTD gsdoc 1.0.4//EN" "http://www.gnustep.org/gsdoc-1_0_4.dtd">
<gsdoc base="ETStackTraceRecorder">
  <head>
    <title>ETStackTraceRecorder documentation</title>
    <author name="Generated by pi"></author>
    <copy>2010 Quentin Mathe</copy>
  </head>
  <body>
    <front><contents /></front>
    <chapter>
      <heading>
        Software documentation for the ETStackTrace class
      </heading>
      <class name="ETStackTrace" super="NSObject">
        <declared>ETStackTraceRecorder.h</declared>
        <desc>
          <p>
            @group Debugging @abstract Represents a stack trace
            built from an array of call stack symbols.
          </p>
          <p>
            You usually don't need to instantiate stack trace
            objects directly, ETStackTraceRecorder does it.
          </p>
        </desc>
        <ivariable type="NSArray*" name="_callStackSymbols" validity="protected">
          <desc>
            <em>Warning</em> the underscore at the start of the
            name of this instance variable indicates that, even
            though it is not technically <em>private</em>, it is
            intended for internal use within the package, and
            you should not use the variable in other code.
          </desc>
        </ivariable>
        <method type="id" init="yes">
          <sel>init</sel>
          <desc>
            <p>
              Returns a new stack trace initialized with the
              call stack symbols of the current thread.
            </p>
          </desc>
        </method>
        <method type="NSUInteger">
          <sel>numberOfFrames</sel>
          <desc>
            <p>
              Returns the number of stack frames.
            </p>
          </desc>
        </method>
      </class>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the ETStackTraceRecorder
        class
      </heading>
      <class name="ETStackTraceRecorder" super="NSObject">
        <declared>ETStackTraceRecorder.h</declared>
        <desc>
          <p>
            @group Debugging @abstract A debug utility to record
            stack traces in relation to an instance.
          </p>
          <p>
            A stack trace recorder allows to snapshot the call stack
            symbols and inspect these snapshots later on.
          </p>
          <p>
            You invoke
            <ref type="method" id="-recordForObject:">
              -recordForObject:
            </ref>
            to snapshot the current call stack symbols and
            <ref type="method" id="-recordedStackTracesForObject:">
              -recordedStackTracesForObject:
            </ref>
            to get all the call stack traces recorded until now.
          </p>
          <p>
            A stack trace recorder is very handy to debug memory
            management issues. e.g. You can easily discover
            where an over-released object was allocated in a vein
            similar to <em>malloc_history</em> on Mac OS X.
            <br /> Take note that
            <ref type="method" id="+enableAllocationRecordingForClass:">+enableAllocationRecordingForClass:</ref> is only available on GNUstep and the example detailed below doesn't apply to Mac OS X where you must use malloc_history instead. <br /> To get meaningfull backtrace on GNUstep, you must install the GNU bin utils (e.g. binutils-dev package on Ubuntu) and configure GNUstep Base with <em>--enable-bfd</em>. <br /> Be aware that the resulting gnustep-base library will be GPL-licensed and transively all the code that links it will become GPL-licensed too.
          </p>
          <p>
            @section Use Case Example
          </p>
          <p>
            For a retain/release crash, note the instance class
            that got double-released, then add in main() or
            equivalent:
          </p>
<example>[[ETStackTraceRecorder sharedInstance] enableAllocationRecordingForClass: [MyClass class]];</example>
          <p>
            To prevent the instance to be deallocated, set
            NSZombieEnabled to <code>YES</code> (e.g.
            <em>export NSZombieEnabled <code>YES</code></em> in
            the shell). Finally compile and run the program in GDB
            and at crash time, type on the GDB prompt:
          </p>
<example>po [[ETStackTraceRecorder sharedInstance] recordedStackTracesForObject: instance] firstObject]</example>
          <p>
            Where <em>instance</em> is the instance address or a
            variable pointing on the instance. Then GDB prints
            the stack trace which points back to the code that
            allocated the instance. <br /> You can also put a
            breakpoint on -[NSZombie forwardInvocation:],
            but take note that NSZombie doesn't respond to
            <ref type="method" id="-recordedStackTraces">
              -recordedStackTraces
            </ref>
            (at least on GNUstep).
          </p>
          <p>
            @section Thread Safety
          </p>
          <p>
            ETStackTraceRecorder is thread-safe
            (not fully yet), multiple threads can invoke
            <ref type="method" id="-recordForObject:">
              -recordForObject:
            </ref>
            .
          </p>
        </desc>
        <method type="instancetype" factory="yes">
          <sel>sharedInstance</sel>
          <desc>
            <p>
              @taskunit Initialization
            </p>
            <p>
              Returns the shared stack trace recorder.
            </p>
            <p>
              Returns the shared stack trace recorder.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>disableAllocationRecordingForClass:</sel>
          <arg type="Class">aClass</arg>
          <desc>
            <p>
              Disables the recording of the stack trace every
              time
              <ref type="method" id="+allocWithZone:">
                +allocWithZone:
              </ref>
              is called on the given class.
            </p>
            <p>
              Doesn't apply subclasses. See
              <ref type="method" id="-enableAllocationRecordingForClass:">-enableAllocationRecordingForClass:</ref> for more details.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>enableAllocationRecordingForClass:</sel>
          <arg type="Class">aClass</arg>
          <desc>
            <p>
              @taskunit Object Allocation Recording
            </p>
            <p>
              Enables the recording of the stack trace every
              time
              <ref type="method" id="+allocWithZone:">
                +allocWithZone:
              </ref>
              is called on the given class.
            </p>
            <p>
              Doesn't apply to subclasses. e.g. Using NSObject
              as argument won't trigger the allocation recording for
              every instances. <br /> You must pass concrete
              subclasses to record class cluster
              allocations. e.g. GSDictionary for
              NSDictionary.
            </p>
            <p>
              For now, using this method on other recorders than
              the one returned by
              <ref type="method" id="+sharedInstance">
                +sharedInstance
              </ref>
              is not supported.
            </p>
            <p>
              To detect object allocations, the receiver sets up
              alloc/dealloc callbacks with
              <ref type="function" id="GSSetDebugAllocationFunctions">
                GSSetDebugAllocationFunctions()
              </ref>
              . You cannot use these hooks in your code and at the
              same time record the allocation with
              ETStackTraceRecorder.
            </p>
            <p>
              Enables the recording of the stack trace every
              time
              <ref type="method" id="+allocWithZone:">
                +allocWithZone:
              </ref>
              is called on the given class.
            </p>
            <p>
              Doesn't apply to subclasses. e.g. Using NSObject
              as argument won't trigger the allocation recording for
              every instances. <br /> You must pass concrete
              subclasses to record class cluster
              allocations. e.g. GSDictionary for
              NSDictionary.
            </p>
            <p>
              For now, using this method on other recorders than
              the one returned by
              <ref type="method" id="+sharedInstance">
                +sharedInstance
              </ref>
              is not supported.
            </p>
            <p>
              To detect object allocations, the receiver sets up
              alloc/dealloc callbacks with
              <ref type="function" id="GSSetDebugAllocationFunctions">
                GSSetDebugAllocationFunctions()
              </ref>
              . You cannot use these hooks in your code and at the
              same time record the allocation with
              ETStackTraceRecorder.
            </p>
          </desc>
        </method>
        <method type="id" init="yes">
          <sel>init</sel>
          <desc>
            <p>
              Initializes and returns a new stack trace
              recorder.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>recordForObject:</sel>
          <arg type="id">anObject</arg>
          <desc>
            <p>
              @taskunit Recording and Accessing Stack Traces
            </p>
            <p>
              Records the call stack symbols in relation to the
              given object.
            </p>
            <p>
              Records the call stack symbols in relation to the
              given object.
            </p>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>recordedStackTracesForObject:</sel>
          <arg type="id">anObject</arg>
          <desc>
            <p>
              Returns an array of stack traces previous
              recorded with
              <ref type="method" id="-recordForObject:">
                -recordForObject:
              </ref>
              for the given object.
            </p>
            <p>
              When no stack traces have been recorded for the
              given object, returns an empty array.
            </p>
          </desc>
        </method>
      </class>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSObject(ETStackTraceRecorderConveniency)
        category
      </heading>
      <category name="ETStackTraceRecorderConveniency" class="NSObject">
        <declared>ETStackTraceRecorder.h</declared>
        <desc>
          <p>
            @group Debugging @abstract Conveniency methods that
            makes easier to work ETStackTraceRecorder.
          </p>
          <p>
            You can use these methods to record stack traces with
            +[ETStackTraceRecorder
            sharedInstance].
          </p>
          <p>
            For example, in GDB you can type [self
            recordStackTrace] to keep a trace of the
            current call stack. <br /> And you can print all
            the stack traces recorded for the current object with
            'po [[self recordedStackTraces] stringValue]'.
          </p>
        </desc>
        <method type="void">
          <sel>recordStackTrace</sel>
          <desc>
            <p>
              Records the call stack symbols with the shared
              stack trace recorder.
            </p>
          </desc>
        </method>
        <method type="NSArray*">
          <sel>recordedStackTraces</sel>
          <desc>
            <p>
              Returns an array of stack traces previously
              recorded with the shared stack trace recorded
              for the receiver.
            </p>
          </desc>
        </method>
      </category>
    </chapter>
  </body>
</gsdoc>
