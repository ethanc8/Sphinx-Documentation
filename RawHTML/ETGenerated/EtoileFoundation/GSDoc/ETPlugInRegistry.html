<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

    <head>
    <title>ETPlugInRegistry class documentation</title>
  </head>
  <body>
    <font face="serif">
    <h1><a name="title$ETPlugInRegistry">ETPlugInRegistry class documentation</a></h1>
    <h3>Authors</h3>
    <dl>
      <dt>Generated by pi</dt>
      <dd>
      </dd>
    </dl>
    <p><b>Copyright:</b> (C) 2004 Uli Kusterer, Quentin Mathe</p>

        <div>
    </div>

          <h1><a name="001000000000">
        Software documentation for the ETPlugInRegistry class
      </a></h1>
    <h2><a name="class$ETPlugInRegistry">ETPlugInRegistry</a> : <a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSObject.html#class$NSObject">NSObject</a></h2>
    <blockquote class="declared">
      <dl>
        <dt><b>Declared in:</b></dt>
        <dd>ETPlugInRegistry.h</dd>
      </dl>
    </blockquote>
    <div class="desc">
      
          
    </p>
    <p>

            @group Plug-Ins @abstract Plug-in manager class used
            to register new plug-ins and obtain already registered
            plug-ins.
              </p>
    <p>
      
          
    </p>
    <p>

            Each plug-in is represented by an NSMutableDictionary
            to which you can add your own entries as needed. The
            keys ETPlugInRegistry adds to this dictionary are:
              </p>
    <p>
      
          
      <dl>
        <dt>bundle</dt>
        <dd>
          NSBundle instance for this plug-in
        </dd>
        <dt>identifier</dt>
        <dd>
          
              Unique identifier for this plug-in (bundle
              identifier in current implementation), see
              <a rel="gsdoc" href="#method$ETPlugInRegistry-plugInIdentifierForBundle$">
                -plugInIdentifierForBundle:
              </a>

            
        </dd>
        <dt>image</dt>
        <dd>
          
              Icon (NSImage) of the plug-in (for display in
              toolbars etc.), see
              <a rel="gsdoc" href="#method$ETPlugInRegistry-plugInIconPathForBundle$">
                -plugInIconPathForBundle:
              </a>

            
        </dd>
        <dt>name</dt>
        <dd>
          
              Display name of the plug-in (for display in
              lists, toolbars etc.), see
              <a rel="gsdoc" href="#method$ETPlugInRegistry-plugInNameForBundle$">
                -plugInNameForBundle:
              </a>

            
        </dd>
        <dt>path</dt>
        <dd>
          Full path to the bundle.
        </dd>
        <dt>class</dt>
        <dd>
          
              Principal class (type <strong>Class</strong>)
              for this bundle, so you can instantiate it
            
        </dd>
        <dt>instance</dt>
        <dd>
          
              If
              <a rel="gsdoc" href="#method$ETPlugInRegistry-shouldInstantiatePlugInClass">
                -shouldInstantiatePlugInClass
              </a>

              is <code>YES</code>, this contains an instance of the
              principal class, instantiated using alloc+init
            
        </dd>
      </dl>
      
          
    </p>
    <p>

            ETPlugInRegistry is thread-safe.
              </p>
    <p>
      
        
    </div>
    <b>Method summary</b>
    <ul>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry+sharedRegistry">+sharedRegistry</a></li>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry-loadPlugInAtPath$">-loadPlugInAtPath:</a></li>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry-loadPlugInsFromPath$ofType$">-loadPlugInsFromPath:ofType:</a></li>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry-loadPlugInsOfType$">-loadPlugInsOfType:</a></li>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry-loadedPlugIns">-loadedPlugIns</a></li>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry-plugInIconPathForBundle$">-plugInIconPathForBundle:</a></li>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry-plugInIdentifierForBundle$">-plugInIdentifierForBundle:</a></li>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry-plugInNameForBundle$">-plugInNameForBundle:</a></li>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry-searchPaths">-searchPaths</a></li>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry-setShouldInstantiatePlugInClass$">-setShouldInstantiatePlugInClass:</a></li>
      <li><a rel="gsdoc" href="ETPlugInRegistry.html#method$ETPlugInRegistry-shouldInstantiatePlugInClass">-shouldInstantiatePlugInClass</a></li>
    </ul>
    <hr width="50%" align="left" />
<div class="method">
    <h3><a name="method$ETPlugInRegistry+sharedRegistry">sharedRegistry&nbsp;</a></h3>
    + (id) <b>sharedRegistry</b>;<br />
    <div class="desc">
      
            
    </p>
    <p>

              @taskunit Initialization
                </p>
    <p>
      
            
    </p>
    <p>

              Returns UKPluginsRegistry shared instance
              (singleton).
                </p>
    <p>
      
            
    </p>
    <p>

              Returns UKPluginsRegistry shared instance
              (singleton).
                </p>
    <p>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
<div class="method">
    <h3><a name="method$ETPlugInRegistry-loadPlugInAtPath$">loadPlugInAtPath:&nbsp;</a></h3>
    - (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSDictionary.html#class$NSMutableDictionary">NSMutableDictionary</a>*) <b>loadPlugInAtPath:</b> (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSString.html#class$NSString">NSString</a>*)path;<br />
    <div class="desc">
      
            
    </p>
    <p>

              Loads the plug-in bundle located at <var>path</var>
              .
                </p>
    <p>
      
            
    </p>
    <p>

              If the plug-in has already been loaded, immediately
              returns the same plug-in than previously.
                </p>
    <p>
      
            
    </p>
    <p>

              Every property list values associated to the
              plug-in schema, detailed in ETPlugInRegistry
              class description, are put in a dictionary which
              represents a plug-in object; eventual validity
              errors may be reported each time a value is read
              in NSBundle description values returned by
              
                -infoDictionary
              

              .
                </p>
    <p>
      
            
    </p>
    <p>

              Raises an NSInvalidArgumentException if
              <var>path</var> is <code>nil</code>.
                </p>
    <p>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
<div class="method">
    <h3><a name="method$ETPlugInRegistry-loadPlugInsFromPath$ofType$">loadPlugInsFromPath:&nbsp;ofType:&nbsp;</a></h3>
    - (void) <b>loadPlugInsFromPath:</b> (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSString.html#class$NSString">NSString</a>*)folder<b> ofType:</b> (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSString.html#class$NSString">NSString</a>*)ext;<br />
    <div class="desc">
      
            
    </p>
    <p>

              Finds plug-ins within <var>folder</var> path which
              are identified by an extension matching
              <var>ext</var>. Finally loads these plug-ins by
              calling
              <a rel="gsdoc" href="#method$ETPlugInRegistry-loadPlugInAtPath$">
                -loadPlugInAtPath:
              </a>

              .
                </p>
    <p>
      
            
    </p>
    <p>

              Raises an NSInvalidArgumentException if
              <var>folder</var> or <var>ext</var> is
              <code>nil</code>.
                </p>
    <p>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
<div class="method">
    <h3><a name="method$ETPlugInRegistry-loadPlugInsOfType$">loadPlugInsOfType:&nbsp;</a></h3>
    - (void) <b>loadPlugInsOfType:</b> (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSString.html#class$NSString">NSString</a>*)ext;<br />
    <div class="desc">
      
            
    </p>
    <p>

              @taskunit Loading Plug-Ins
                </p>
    <p>
      
            
    </p>
    <p>

              Locates and loads plug-in bundles with extension
              <var>ext</var> in the application-dedicated
              directory inside the Application Support
              directory.
                </p>
    <p>
      
            
    </p>
    <p>

              If the application&apos;s name (taken from NSExecutable in
              the plist package) is &apos;Typewriter&apos;, then
              Library/ApplicationSupport/Typewriter
              will be searched. This search will be repeated in
              each library per domain (user, system etc.). <br />
              This method takes in account the naming variation of
              the system directories between GNUstep and Mac OS X
              (e.g. Application Support vs ApplicationSupport).
              <br /> See
              <a rel="gsdoc" href="#method$ETPlugInRegistry-searchPaths">
                -searchPaths
              </a>

              .
                </p>
    <p>
      
            
    </p>
    <p>

              If the executable is a tool rather than an
              application, does nothing.
                </p>
    <p>
      
            
    </p>
    <p>

              Normally this is the only method you need to
              call to load a plug-in.
                </p>
    <p>
      
            
    </p>
    <p>

              Raises an NSInvalidArgumentException if
              <var>ext</var> is <code>nil</code>.
                </p>
    <p>
      
            
    </p>
    <p>

              Locates and loads plug-in bundles with extension
              <var>ext</var> in the application-dedicated
              directory inside the Application Support
              directory.
                </p>
    <p>
      
            
    </p>
    <p>

              If the application&apos;s name (taken from NSExecutable in
              the plist package) is &apos;Typewriter&apos;, then
              Library/ApplicationSupport/Typewriter
              will be searched. This search will be repeated in
              each library per domain (user, system etc.). <br />
              This method takes in account the naming variation of
              the system directories between GNUstep and Mac OS X
              (e.g. Application Support vs ApplicationSupport).
              <br /> See
              <a rel="gsdoc" href="#method$ETPlugInRegistry-searchPaths">
                -searchPaths
              </a>

              .
                </p>
    <p>
      
            
    </p>
    <p>

              If the executable is a tool rather than an
              application, does nothing.
                </p>
    <p>
      
            
    </p>
    <p>

              Normally this is the only method you need to
              call to load a plug-in.
                </p>
    <p>
      
            
    </p>
    <p>

              Raises an NSInvalidArgumentException if
              <var>ext</var> is <code>nil</code>.
                </p>
    <p>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
<div class="method">
    <h3><a name="method$ETPlugInRegistry-loadedPlugIns">loadedPlugIns&nbsp;</a></h3>
    - (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSArray.html#class$NSArray">NSArray</a>*) <b>loadedPlugIns</b>;<br />
    <div class="desc">
      
            
    </p>
    <p>

              @taskunit Accessing Plug-Ins
                </p>
    <p>
      
            
    </p>
    <p>

              Returns the currently registered plug-ins (loaded
              by the way).
                </p>
    <p>
      
            
    </p>
    <p>

              An empty array is returned when no plug-ins have been
              registered.
                </p>
    <p>
      
            
    </p>
    <p>

              Returns the currently registered plug-ins (loaded
              by the way).
                </p>
    <p>
      
            
    </p>
    <p>

              An empty array is returned when no plug-ins have been
              registered.
                </p>
    <p>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
<div class="method">
    <h3><a name="method$ETPlugInRegistry-plugInIconPathForBundle$">plugInIconPathForBundle:&nbsp;</a></h3>
    - (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSString.html#class$NSString">NSString</a>*) <b>plugInIconPathForBundle:</b> (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSBundle.html#class$NSBundle">NSBundle</a>*)bundle;<br />
    <div class="desc">
      
            
    </p>
    <p>

              Returns the plug-in icon path from the given
              <var>bundle</var> info dictionary.
                </p>
    <p>
      
            
    </p>
    <p>

              Valid <em>image</em> path keys in the plug-in
              property list are:
                </p>
    <p>
      
            
      <ul>
        <li>
          CFBundleIcon
        </li>
        <li>
          NSPrefPaneIconFile
        </li>
        <li>
          NSIcon
        </li>
        <li>
          NSApplicationIcon
        </li>
      </ul>
      
            
    </p>
    <p>

              If there is no valid key, returns <code>nil</code>.
                </p>
    <p>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
<div class="method">
    <h3><a name="method$ETPlugInRegistry-plugInIdentifierForBundle$">plugInIdentifierForBundle:&nbsp;</a></h3>
    - (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSString.html#class$NSString">NSString</a>*) <b>plugInIdentifierForBundle:</b> (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSBundle.html#class$NSBundle">NSBundle</a>*)bundle;<br />
    <div class="desc">
      
            
    </p>
    <p>

              Returns the plug-in identifier from the given
              <var>bundle</var> info dictionary.
                </p>
    <p>
      
            
    </p>
    <p>

              Valid <em>identifier</em> keys in the plug-in
              property list are:
                </p>
    <p>
      
            
      <ul>
        <li>
          CFBundleIdentifier
        </li>
      </ul>
      
            
    </p>
    <p>

              If there is no valid key, returns the
              <var>bundle</var> path.
                </p>
    <p>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
<div class="method">
    <h3><a name="method$ETPlugInRegistry-plugInNameForBundle$">plugInNameForBundle:&nbsp;</a></h3>
    - (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSString.html#class$NSString">NSString</a>*) <b>plugInNameForBundle:</b> (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSBundle.html#class$NSBundle">NSBundle</a>*)bundle;<br />
    <div class="desc">
      
            
    </p>
    <p>

              @taskunit Retrieving Plug-In Schema Infos
                </p>
    <p>
      
            
    </p>
    <p>

              Returns the plug-in name from the given
              <var>bundle</var> info dictionary.
                </p>
    <p>
      
            
    </p>
    <p>

              Valid <em>name</em> keys in the plug-in property
              list are:
                </p>
    <p>
      
            
      <ul>
        <li>
          CFBundleName
        </li>
        <li>
          NSPrefPaneIconLabel
        </li>
        <li>
          ApplicationName
        </li>
        <li>
          NSExecutable
        </li>
      </ul>
      
            
    </p>
    <p>

              If there is no valid key, returns <em>Unknown</em>.
                </p>
    <p>
      
            
    </p>
    <p>

              Returns the plug-in name from the given
              <var>bundle</var> info dictionary.
                </p>
    <p>
      
            
    </p>
    <p>

              Valid <em>name</em> keys in the plug-in property
              list are:
                </p>
    <p>
      
            
      <ul>
        <li>
          CFBundleName
        </li>
        <li>
          NSPrefPaneIconLabel
        </li>
        <li>
          ApplicationName
        </li>
        <li>
          NSExecutable
        </li>
      </ul>
      
            
    </p>
    <p>

              If there is no valid key, returns <em>Unknown</em>.
                </p>
    <p>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
<div class="method">
    <h3><a name="method$ETPlugInRegistry-searchPaths">searchPaths&nbsp;</a></h3>
    - (<a rel="gsdoc" href="/usr/GNUstep/Local/Library/Documentation/Developer/Base/Reference/NSArray.html#class$NSArray">NSArray</a>*) <b>searchPaths</b>;<br />
    <div class="desc">
      
            
    </p>
    <p>

              Returns the paths where plug-ins should be
              searched by
              <a rel="gsdoc" href="#method$ETPlugInRegistry-loadPlugInsOfType$">
                -loadPlugInsOfType:
              </a>

              .
                </p>
    <p>
      
            
    </p>
    <p>

              If the executable is a tool rather than an
              application, returns an empty array.
                </p>
    <p>
      
            
    </p>
    <p>

              TODO: Allow to customize search paths.
                </p>
    <p>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
<div class="method">
    <h3><a name="method$ETPlugInRegistry-setShouldInstantiatePlugInClass$">setShouldInstantiatePlugInClass:&nbsp;</a></h3>
    - (void) <b>setShouldInstantiatePlugInClass:</b> (BOOL)instantiate;<br />
    <div class="desc">
      
            
    </p>
    <p>

              Sets to <code>YES</code> if you want to have plug-in
              main class automatically instantiated when they are
              loaded, otherwise it&apos;s your responsability to
              retrieve the plug-in class and
              <var>instantiate</var> it. This is especially
              useful if a custom initializer is required to make
              the instantiation. For example:
                </p>
    <p>
      

<pre>
Class plugInClass = [[registry loadPlugInAtPath: path] objectForKey: @&quot;class&quot;];
CustomObject *mainObject = [[plugInClass alloc] initWithCity: @&quot;Somewhere&quot;];
</pre>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
<div class="method">
    <h3><a name="method$ETPlugInRegistry-shouldInstantiatePlugInClass">shouldInstantiatePlugInClass&nbsp;</a></h3>
    - (BOOL) <b>shouldInstantiatePlugInClass</b>;<br />
    <div class="desc">
      
            
    </p>
    <p>

              @taskunit Loading Behavior
                </p>
    <p>
      
            
    </p>
    <p>

              Returns whether plug-in class should be
              instantiated at loading time by the
              registry.
                </p>
    <p>
      
            
    </p>
    <p>

              By default, returns <code>YES</code>.
                </p>
    <p>
      
            
    </p>
    <p>

              Read
              <a rel="gsdoc" href="#method$ETPlugInRegistry-setShouldInstantiatePlugInClass$">-setShouldInstantiatePlugInClass:</a>
 documentation to learn more.
                </p>
    <p>
      
            
    </p>
    <p>

              Returns whether plug-in class should be
              instantiated at loading time by the
              registry.
                </p>
    <p>
      
            
    </p>
    <p>

              By default, returns <code>YES</code>.
                </p>
    <p>
      
            
    </p>
    <p>

              Read
              <a rel="gsdoc" href="#method$ETPlugInRegistry-setShouldInstantiatePlugInClass$">-setShouldInstantiatePlugInClass:</a>
 documentation to learn more.
                </p>
    <p>
      
          
    </div>
    <hr width="25%" align="left" />
</div>
    <br />
    </font>
</body>
</html>
