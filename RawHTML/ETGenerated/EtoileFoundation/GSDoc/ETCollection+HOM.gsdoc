<?xml version="1.0"?>
<!DOCTYPE gsdoc PUBLIC "-//GNUstep//DTD gsdoc 1.0.4//EN" "http://www.gnustep.org/gsdoc-1_0_4.dtd">
<gsdoc base="ETCollection+HOM">
  <head>
    <title>ETCollection+HOM documentation</title>
    <author name="Generated by pi"></author>
    <copy>2009 Niels Grewe</copy>
  </head>
  <body>
    <front><contents /></front>
    <chapter>
      <heading>
        Software documentation for the
        NSArray(ETCollectionHOM) category
      </heading>
      <category name="ETCollectionHOM" class="NSArray">
        <declared>ETCollection+HOM.h</declared>
        <conform>ETCollectionHOM</conform>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Higher-order messaging support for NSArray.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSDictionary(ETCollectionHOM)
        category
      </heading>
      <category name="ETCollectionHOM" class="NSDictionary">
        <declared>ETCollection+HOM.h</declared>
        <conform>ETCollectionHOM</conform>
        <conform>ETCollectionHOMIntegration</conform>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Higher-order messaging support for
            NSDictionary.
          </p>
        </desc>
        <method type="NSArray*">
          <sel>collectionArrayAndInfo:</sel>
          <arg type="id*">info</arg>
          <desc>
            <p>
              Returns objects in the dictionary, and the keys
              as an array with the <var>info</var> argument.
            </p>
            <p>
              Both objects and keys are returned in the same order
              (this ordering ensures that each index corresponds
              to a key-value pair that exists in the dictionary).
            </p>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSIndexSet(ETCollectionHOM)
        category
      </heading>
      <category name="ETCollectionHOM" class="NSIndexSet">
        <declared>ETCollection+HOM.h</declared>
        <conform>ETCollectionHOM</conform>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Higher-order messaging support for NSIndexSet.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSMutableArray(ETCollectionHOM)
        category
      </heading>
      <category name="ETCollectionHOM" class="NSMutableArray">
        <declared>ETCollection+HOM.h</declared>
        <conform>ETCollectionMutationHOM</conform>
        <conform>ETCollectionHOMMapIntegration</conform>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Higher-order messaging with in-place mutation
            support for NSMutableArray.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSMutableDictionary(ETCollectionHOM)
        category
      </heading>
      <category name="ETCollectionHOM" class="NSMutableDictionary">
        <declared>ETCollection+HOM.h</declared>
        <conform>ETCollectionMutationHOM</conform>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Higher-order messaging with in-place mutation
            support for NSMutableDictionary.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSMutableIndexSet(ETCollectionHOM)
        category
      </heading>
      <category name="ETCollectionHOM" class="NSMutableIndexSet">
        <declared>ETCollection+HOM.h</declared>
        <conform>ETCollectionMutationHOM</conform>
        <conform>ETCollectionHOMMapIntegration</conform>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Higher-order messaging with in-place mutation
            support for NSMutableIndexSet.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSMutableSet(ETCollectionHOM)
        category
      </heading>
      <category name="ETCollectionHOM" class="NSMutableSet">
        <declared>ETCollection+HOM.h</declared>
        <conform>ETCollectionMutationHOM</conform>
        <conform>ETCollectionHOMMapIntegration</conform>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Higher-order messaging with in-place mutation
            support for NSMutableSet.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        NSObject(ETCollectionHOMIntegrationInformalProtocol)
        informal protocol
      </heading>
      <category name="ETCollectionHOMIntegrationInformalProtocol" class="NSObject">
        <declared>ETCollection+HOM.h</declared>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Procotol to integrate high-order messaging with
            collections that require special treatments of
            their elements.
          </p>
        </desc>
        <method type="NSArray*">
          <sel>collectionArrayAndInfo:</sel>
          <arg type="id*">info</arg>
          <desc>
            <p>
              Returns the array representation used to evaluate
              high-order messages.
            </p>
            <p>
              If not implemented,
              <ref type="method" id="-contentArray">
                -contentArray
              </ref>
              is used.
            </p>
            <p>
              If <var>info</var> is not NULL, you can return
              additional information to be passed to the
              element-handling hook
              <ref type="method" id="-placeObject:inCollection:insteadOfObject:atIndex:havingAlreadyMapped:info:">-placeObject:inCollection:insteadOfObject:atIndex:havingAlreadyMapped:info:</ref>.
            </p>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSObject(ETEachHOM)
        category
      </heading>
      <category name="ETEachHOM" class="NSObject">
        <declared>ETCollection+HOM.h</declared>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Extends ETCollection to support the 'each'
            higher-order message.
          </p>
        </desc>
        <method type="id">
          <sel>each</sel>
          <desc>
            <p>
              If the receiver conforms to the ETCollection protocol,
              this method returns a proxy that will let
              <ref type="method" id="-map">
                -map
              </ref>
              and <ref type="method" id="-filter">-filter</ref>
              methods iterate over the contents of the
              collection when it is used as an argument to a
              message. This way,
              <code>
                [[people map] sendMail: [messages each]];
              </code>
              will cause the
              <ref type="method" id="-sendMail:">
                -sendMail:
              </ref>
              message to be executed once with every
              combination of elements from the
              <code>people</code> and the <code>messages</code>
              collection.
            </p>
            <p>
              Note 1: It is only possible to use an proxy object
              created with
              <ref type="method" id="-each">
                -each
              </ref>
              if it is passed as an argument to a message that is
              send to a higher-order messaging proxy created by
              <ref type="method" id="-filter">
                -filter
              </ref>
              , <ref type="method" id="-map">-map</ref>,
              <ref type="method" id="-filteredCollection">
                -filteredCollection
              </ref>
              or
              <ref type="method" id="-mappedCollection">
                -mappedCollection
              </ref>
              . Doing
              <code>
                [aCollection addObject: [things each]]
              </code>
              won't do anything.
            </p>
            <p>
              Note 2: If an each proxy is passed to a message used
              as a filter predicate, it suffices that the predicate
              evaluates to <code>YES</code> for one element
              of the argument-collection. If a collection
              <code>A</code> contains "foo" and "bar" and
              collection <code>B</code> contains "BAR" and
              "bar", after
              <code>
                [[A filter] isEqualToString: [B each]];
              </code>
              , <code>A</code> will still contain "bar" (but not
              "BAR"), since one of the elements of
              <code>B</code> matched "bar".
            </p>
          </desc>
        </method>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the NSSet(ETCollectionHOM)
        category
      </heading>
      <category name="ETCollectionHOM" class="NSSet">
        <declared>ETCollection+HOM.h</declared>
        <conform>ETCollectionHOM</conform>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Higher-order messaging support for NSSet.
          </p>
        </desc>
      </category>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the ETCollectionHOM
        protocol
      </heading>
      <protocol name="ETCollectionHOM">
        <declared>ETCollection+HOM.h</declared>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Higher-order messaging additions to
            ETCollection.
          </p>
        </desc>
        <method type="id">
          <sel>filteredCollectionWithBlock:</sel>
          <arg type="BOOL(^)(id)">aBlock</arg>
          <desc>
            <p>
              Returns a collection containing all elements of
              the original collection that respond with
              <code>YES</code> to <var>aBlock</var>.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>filteredOutCollectionWithBlock:</sel>
          <arg type="BOOL(^)(id)">aBlock</arg>
          <desc>
            <p>
              Returns a collection containing all elements of
              the original collection that respond with
              <code>NO</code> to <var>aBlock</var>.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>leftFold</sel>
          <desc>
            <p>
              Returns a proxy object that can be used to
              perform a left fold on the collection. The value
              of the first argument of any method used as a folding
              method is taken to be the initial value of the
              accumulator, with the accumulator being used
              as the receiver of the folding method.
            </p>
            <p>
              Example:
              <code>
                total = [[salaries leftFold] addAmount:
                nullSalary];
              </code>
              will compute <code>total</code> of all elements in
              <code>salaries</code> by using the
              <code>
                <ref type="method" id="-addAmount:">
                  -addAmount:
                </ref>
              </code>
              message.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>leftFoldWithInitialValue:</sel>
          <arg type="id">initialValue</arg>
          <sel>intoBlock:</sel>
          <arg type="id">aBlock</arg>
          <desc>
            <p>
              Folds the collection by applying <var>aBlock</var>
              consecutively with the accumulator as the
              first and each element as the second argument of
              the block.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>mappedCollection</sel>
          <desc>
            <p>
              Returns a proxy object on which methods can be
              called. These methods will cause a collection to
              be returned containing the elements of the original
              collection mapped by the method call.
            </p>
            <p>
              Example:
              <code>
                addresses = [[people mappedCollection]
                address];
              </code>
              will cause <code>addresses</code> to be a collection
              created by sending
              <code>
                <ref type="method" id="-address">
                  -address
                </ref>
              </code>
              to every element in <code>people</code>.
            </p>
            <p>
              Note: Can be used to send the same message to
              multiple objects even if the message returns
              <strong>void</strong>, then the result is not a
              new collection but <code>nil</code>. For example,
              <code>
                [[people mappedCollection] setCity: @"New
                York"]
              </code>
              .
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>mappedCollectionWithBlock:</sel>
          <arg type="id">aBlock</arg>
          <desc>
            <p>
              Returns a collection with each element of the
              original collection mapped by applying
              <var>aBlock</var> where <var>aBlock</var> takes one
              argument of type <strong>id</strong> and returns
              <strong>id</strong>.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>rightFold</sel>
          <desc>
            <p>
              Returns a proxy object that can be used to
              perform a right fold on the collection. The value
              of the first argument of any method used as a folding
              method is taken to be the initial value of the
              accumulator, with the accumulator being used
              as the argument of the folding method.
            </p>
            <p>
              Example: If <code>characters</code> is an
              ordered collection containing "x", "y" and "z"
              (in that order),
              <code>
                [[characters rightFold]
                stringByAppendingString: @":
                end"];
              </code>
              will produce "xyz: end".
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>rightFoldWithInitialValue:</sel>
          <arg type="id">initialValue</arg>
          <sel>intoBlock:</sel>
          <arg type="id">aBlock</arg>
          <desc>
            <p>
              Folds the collection by applying <var>aBlock</var>
              consecutively with the accumulator as the
              second and each element (beginning with the last)
              as the first argument of the block.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>zippedCollectionWithCollection:</sel>
          <arg type="id&lt;NSObject,ETCollection&gt;">aCollection</arg>
          <desc>
            <p>
              Returns a proxy object the will use the next
              message received to coalesce the receiver and
              <var>aCollection</var> into one collection by
              sending the message to every element of the
              receiver with the corresponding element of the
              second collection as an argument. The first
              argument (after the implicit receiver and
              selector arguments) of the message is thus
              ignored. The operation will stop at the end of
              the shorter collection.
            </p>
            <p>
              Example: If collection <code>A</code> contains
              "foo" and "FOO", and collection <code>B</code>
              "bar" and "BAR",
              <code>
                [[A zippedCollectionWithCollection: B]
                stringByAppendingString:
                <code>nil</code>];
              </code>
              will produce a collection containing "foobar" and
              "FOOBAR".
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>zippedCollectionWithCollection:</sel>
          <arg type="id&lt;NSObject,ETCollection&gt;">aCollection</arg>
          <sel>andBlock:</sel>
          <arg type="id">aBlock</arg>
          <desc>
            <p>
              Coalesces the receiver and the collection named
              by <var>aCollection</var> into one collection by
              applying <var>aBlock</var> (where
              <var>aBlock</var> takes two arguments of type
              <strong>id</strong>) to all element-pairs built
              from the receiver and <var>aCollection</var>. The
              operation will stop at the end of the shorter
              collection.
            </p>
            <p>
              Example: For A={a,b} and B={c,d,e}
              <code>
                C = [A zippedCollectionWithCollection: B andBlock: ^
                NSString* (NSString *foo, NSString *bar)
                {return [foo stringByAppendingString: bar];}];
              </code>
              will result in C={ac,bd}.
            </p>
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        ETCollectionHOMFilterIntegration
        protocol
      </heading>
      <protocol name="ETCollectionHOMFilterIntegration">
        <declared>ETCollection+HOM.h</declared>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            ETCollection optional protocol to support the
            filter operation.
          </p>
          <p>
            The ETCollectionHOMFilterIntegration protocol defines a
            hook that collections can use to tie into higher-order
            messaging if they need special treatment of their
            elements.
          </p>
        </desc>
        <method type="void">
          <sel>placeObject:</sel>
          <arg type="id">anObject</arg>
          <sel>atIndex:</sel>
          <arg type="NSUInteger">index</arg>
          <sel>inCollection:</sel>
          <arg type="id&lt;ETCollectionMutation&gt;*">aTarget</arg>
          <sel>basedOnFilter:</sel>
          <arg type="BOOL">shallInclude</arg>
          <sel>info:</sel>
          <arg type="id">info</arg>
          <desc>
            <p>
              This method will be called by the filter proxy.
            </p>
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        ETCollectionHOMIntegration protocol
      </heading>
      <protocol name="ETCollectionHOMIntegration">
        <declared>ETCollection+HOM.h</declared>
        <conform>ETCollectionHOMMapIntegration</conform>
        <conform>ETCollectionHOMFilterIntegration</conform>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            ETCollection optional protocol to support map,
            zip and filter operations.
          </p>
        </desc>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the
        ETCollectionHOMMapIntegration
        protocol
      </heading>
      <protocol name="ETCollectionHOMMapIntegration">
        <declared>ETCollection+HOM.h</declared>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            ETCollection optional protocol to support the
            map and zip operations.
          </p>
          <p>
            The ETCollectionHOMMapIntegration protocol defines a
            hook that collections can use to tie into higher-order
            messaging if they need special treatment of their
            elements.
          </p>
        </desc>
        <method type="void">
          <sel>placeObject:</sel>
          <arg type="id">mappedObject</arg>
          <sel>inCollection:</sel>
          <arg type="id&lt;ETCollectionMutation&gt;*">aTarget</arg>
          <sel>insteadOfObject:</sel>
          <arg type="id">originalObject</arg>
          <sel>atIndex:</sel>
          <arg type="NSUInteger">index</arg>
          <sel>havingAlreadyMapped:</sel>
          <arg type="NSArray*">alreadyMapped</arg>
          <sel>info:</sel>
          <arg type="id">info</arg>
          <desc>
            <p>
              This method will be called by the map- and
              zip-functions and allows the receiver to
              control how the replacement object is placed in
              the target collection (which might be identical to
              the receiver). Classes adopting the
              ETCollectionHOMMapIntegration
              protocol can also implement the
              <code>
                <ref type="method" id="-collectionArrayAndInfo:">
                  -collectionArrayAndInfo:
                </ref>
              </code>
              to provide additional information (e.g. about the
              original state of the collection, which will be
              passed as <var>mapInfo</var> here.
            </p>
          </desc>
        </method>
      </protocol>
    </chapter>
    <chapter>
      <heading>
        Software documentation for the ETCollectionMutationHOM
        protocol
      </heading>
      <protocol name="ETCollectionMutationHOM">
        <declared>ETCollection+HOM.h</declared>
        <desc>
          <p>
            @group High Order Messaging and Blocks @abstract
            Higher-order messaging additions to
            ETCollectionMutation.
          </p>
          <p>
            These higher-order methods mutate the receiver
            collection in-place.
          </p>
        </desc>
        <method type="id">
          <sel>filter</sel>
          <desc>
            <p>
              Returns a proxy object on which methods with
              return type BOOL can be called. Only elements that
              respond with <code>YES</code> to the method call
              will remain in the collection. If there are any
              object returning messages sent to the proxy before
              the predicate, these messages will be applied to the
              elements in the collection before the test is
              performed. It is thus possible to filter a
              collection based on attributes of an object:
              <code>
                [[[persons filter] firstName] isEqual:
                @"Alice"]
              </code>
            </p>
            <p>
              The returned boolean that corresponds to the last
              message is undetermined. For example, the code
              below is meaningless:
              <code>
                if ([[[persons filter] firstName] isEqual:
                @"Alice"]) doSomething;
              </code>
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>filterOut</sel>
          <desc>
            <p>
              Filters a collection the same way
              <ref type="method" id="-filter">
                -filter
              </ref>
              does, but only includes objects that respond with
              <code>NO</code> to the predicate.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>filterOutWithBlock:</sel>
          <arg type="BOOL(^)(id)">aBlock</arg>
          <desc>
            <p>
              Removes all elements from the collection for
              which the <var>aBlock</var> does not return
              <code>NO</code>.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>filterWithBlock:</sel>
          <arg type="BOOL(^)(id)">aBlock</arg>
          <desc>
            <p>
              Removes all elements from the collection for
              which the <var>aBlock</var> does not return
              <code>YES</code>.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>map</sel>
          <desc>
            <p>
              Returns a proxy object on which methods can be
              called. These methods will cause each element in
              the collection to be replaced with the return value
              of the method call.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>mapWithBlock:</sel>
          <arg type="id">aBlock</arg>
          <desc>
            <p>
              Replaces each element in the collection with the
              result of applying <var>aBlock</var> to it. The
              blocks takes one argument of type
              <strong>id</strong>.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>zipWithCollection:</sel>
          <arg type="id&lt;NSObject,ETCollection&gt;">aCollection</arg>
          <desc>
            <p>
              Returns a proxy object which will coalesce the
              collection named by <var>aCollection</var>
              into the first collection by sending all messages
              sent to the proxy to the elements of the receiver
              with the corresponding element of
              <var>aCollection</var> as an argument. The first
              argument of the message (after the implicit
              receiver and selector arguments) is thus
              ignored. The operation will stop at the end of
              the shorter collection.
            </p>
          </desc>
        </method>
        <method type="void">
          <sel>zipWithCollection:</sel>
          <arg type="id&lt;NSObject,ETCollection&gt;">aCollection</arg>
          <sel>andBlock:</sel>
          <arg type="id">aBlock</arg>
          <desc>
            <p>
              Coalesces the second collection into the first
              by applying <var>aBlock</var> (where <var>aBlock</var>
              takes two arguments of type <strong>id</strong>) to
              all element pairs. Processing will stop at the end of
              the shorter collection.
            </p>
          </desc>
        </method>
      </protocol>
    </chapter>
  </body>
</gsdoc>
