<?xml version="1.0"?>
<!DOCTYPE gsdoc PUBLIC "-//GNUstep//DTD gsdoc 1.0.4//EN" "http://www.gnustep.org/gsdoc-1_0_4.dtd">
<gsdoc base="ETModelElementDescription">
  <head>
    <title>ETModelElementDescription class documentation</title>
    <author name="Generated by pi"></author>
    <copy>2009 Eric Wasylishen</copy>
  </head>
  <body>
    <front><contents /></front>
    <chapter>
      <heading>
        Software documentation for the
        ETModelElementDescription class
      </heading>
      <class name="ETModelElementDescription" super="NSObject">
        <declared>ETModelElementDescription.h</declared>
        <desc>
          <p>
            @group Metamodel @abstract Abstract base class used
            by Model Description core classes.
          </p>
          <p>
            The Model Description classes implement a Metamodel
            framework inspired by
            <ref type="class" id="FAME">FAME</ref>
              (http://scg.unibe.ch/wiki/projects/fame).
            </p>
            <p>
              Within this Metamodel, ETModelElementDescription
              provide basic abilities:
            </p>
            <list>
              <item>
                Unique Naming per element in a
                ETModelDescriptionRepository,
                see
                <ref type="method" id="-fullName">
                  -fullName
                </ref>
              </item>
              <item>
                Ownership per element in a
                ETPackageDescription, see
                <ref type="method" id="-owner">
                  -owner
                </ref>
              </item>
              <item>
                Constraint Checking, see
                <ref type="method" id="-checkConstraints:">
                  -checkConstraints:
                </ref>
              </item>
              <item>
                Freezing to prevent changes to a Metamodel
                (useful to support immutable versioned
                metamodels, e.g. a Persistency Schema), see
                <ref type="method" id="-makeFrozen">
                  -makeFrozen
                </ref>
              </item>
            </list>
            <p>
              ETEntityDescription,
              ETPropertyDescription and
              ETPackageDescription all inherit
              from ETModelElementDescription. A model element
              description can be registered inside a model
              description repository using
              -[ETModelDescriptionRepository
              addDescription:].
            </p>
            <p>
              @section Conceptual Model
            </p>
            <p>
              This metamodel is based on the [FM3
              specification](http://scg.unibe.ch/wiki/projects/fame/fm3).
            </p>
            <p>
              For a good introduction, read the paper [FAME — A
              Polyglot Library for Metamodeling at
              Runtime](http://www.iam.unibe.ch/~akuhn/d/Kuhn-2008-MRT-Fame.pdf)
            </p>
            <p>
              We support the entire FM3 specification with some
              minor adjustements, however the tower (model,
              metamodel, meta-metamodel) is not explicitly
              modeled in the API unlike in FAME.
            </p>
            <p>
              The MSE serialization format is also unsupported. In
              the future, we will provide our own exchange format
              based on JSON.
            </p>
            <p>
              @section FAME Terminology Change Summary
            </p>
            <p>
              Those changes were made to further simplify the
              FAME terminology which can get obscure since it
              overlaps with the host language object model,
              prevent any conflict with existing GNUstep/Cocoa
              API and reuse GNUstep/Cocoa naming habits.
            </p>
            <p>
              We list the FAME term first, then its equivalent name
              in EtoileFoundation:
            </p>
            <deflist>
              <term>FM3.Element</term>
              <desc>ETModelElementDescription</desc>
              <term>FM3.Class</term>
              <desc>ETEntityDescription</desc>
              <term>FM3.Property</term>
              <desc>ETPropertyDescription</desc>
              <term>FM3.RuntimeElement</term>
              <desc>ETAdaptiveModelObject</desc>
              <term>
                attributes (in <strong>Class</strong>)
              </term>
              <desc>
                propertyDescriptions (in
                ETEntityDescription)
              </desc>
              <term>
                allAttributes (in <strong>Class</strong>)
              </term>
              <desc>
                allPropertyDescriptions (in
                ETEntityDescription)
              </desc>
              <term>
                superclass (in <strong>Class</strong>)
              </term>
              <desc>parent (in ETEntityDescription)</desc>
              <term>package (in <strong>Class</strong>)</term>
              <desc>owner (in ETEntityDescription)</desc>
              <term>class (in Property)</term>
              <desc>owner (in ETPropertyDescription)</desc>
            </deflist>
            <p>
              For the last two points, we can consider
              FM3.Property.class and
              FM3.Class.package have been merged into
              a single FM3.Element.owner property in EtoileFoundation
              since they were redundant.
            </p>
            <p>
              @section Changes to FAME
            </p>
            <p>
              In EtoileFoundation, there is a
              <ref type="method" id="-owner">
                -owner
              </ref>
              property that represents either:
            </p>
            <list>
              <item>
                a owning entity in ETPropertyDescription
              </item>
              <item>
                an owning package in ETEntityDescription
              </item>
              <item>
                no owner (-owner returns <code>nil</code>) in
                ETPackageDescription
              </item>
            </list>
            <p>
              While in FAME, owner is a derived property and
              these various owner kinds are each modeled using a
              distinct property (class in FM3.Property and
              package in FM3.Class).
            </p>
            <p>
              In FAME, container implies not multivalued. In
              EtoileFoundation, multivalued now
              controls whether a property is a container or
              not, and
              <ref type="method" id="-isContainer">
                -isContainer
              </ref>
              is now derived.
            </p>
            <p>
              Unlike FAME, EtoileFoundation does support
              overriding property descriptions. This is
              mainly useful, for read-only properties overriden
              as read-write in subclasses/subentities.
            </p>
            <p>
              @section Additions to FAME
            </p>
            <p>
              <ref type="method" id="-isPersistent">
                -isPersistent
              </ref>
              has been added to control the persistency, how the
              interpret the metamodel and its constraints for
              the framework providing the persistent support is up
              to this framework. For now, some CoreObject
              constraints are harcoded in the metamodel.
            </p>
            <p>
              <ref type="method" id="-isReadOnly">
                -isReadOnly
              </ref>
              has been added to support set-once properties.
            </p>
            <p>
              <ref type="method" id="-itemIdentifier">
                -itemIdentifier
              </ref>
              has been added as a mean to get precise control over
              the UI generation with EtoileUI.
            </p>
            <p>
              @section Removals to FAME/EMOF
            </p>
            <p>
              NamedElement and NestedElement protocols
              don't exist explicitly.
            </p>
            <p>
              Property description names can be in upper case
              (FAME was imposing lower case as a constraint).
            </p>
            <p>
              @section Metamodel Constraint Summary
            </p>
            <p>
              Metamodel constraints are checked in
              <ref type="method" id="-checkConstraints:">
                -checkConstraints:
              </ref>
              , while model constraints are validated in
              -[ETPropertyDescription
              validateValue:forKey:].
            </p>
            <p>
              Note: In the future,
              <ref type="method" id="-checkConstraints:">
                -checkConstraints:
              </ref>
              should probably be delegated to
              -[ETPropertyDescription
              validateValue:forKey:] in the
              meta-metamodel
            </p>
            <p>
              If we sum up the changes to the FAME conceptual model,
              for the new ETPropertyDescription, the metamodel
              constraints are:
            </p>
            <list>
              <item>
                composite is derived from opposite.container
              </item>
              <item>
                derived and not multivalued implies container
              </item>
              <item>derived implies not persistent</item>
              <item>
                if set, opposite.opposite must be self (i.e.
                opposite properties must refer to each other)
              </item>
              <item>if set, opposite.owner must be type</item>
              <item>owner must not be <code>nil</code></item>
              <item>type must not be <code>nil</code></item>
            </list>
            <p>
              At the model level, the semantics are:
            </p>
            <list>
              <item>
                container property chains may not include
                cycles
              </item>
              <item>
                opposite properties must refer to each other
              </item>
              <item>
                any multivalued property defaults to empty
              </item>
              <item>boolean properties default to false</item>
              <item>
                non primitive properties default to
                <code>nil</code>
              </item>
              <item>
                string and number properties do not have a
                default value (could be changed later)
              </item>
            </list>
            <p>
              Note: The two first points are model constraints,
              but -[ETPropertyDescription validateValue:forKey:]
              doesn't check them.
            </p>
            <p>
              Since the metamodel is the model of the
              meta-metamodel, the model semantics apply
              to the metamodel too.
            </p>
            <p>
              For the new ETEntityDescription, the metamodel
              constraints are:
            </p>
            <list>
              <item>parent is not <code>nil</code></item>
              <item>
                parent must not be a primitive, unless self is a
                primitive
              </item>
              <item>
                parent chain may not include cycles (could be
                removed, this comes from 'container property
                chains may not include cycles' in the model
                semantics of ETPropertyDescription)
              </item>
              <item>package must not be <code>nil</code></item>
              <item>
                allPropertyDescriptions is
                derived as union of propertyDescription and
                parent.allPropertyDescriptions
              </item>
              <item>
                elements in propertyDescriptions override
                identically named elements from
                parent.propertyDescriptions
                in allPropertyDescriptions
              </item>
              <item>
                allPropertyDescriptions must
                have unique names
              </item>
            </list>
            <p>
              For the new ETPackageDescription, the metamodel
              constraints are:
            </p>
            <list>
              <item>owner is not <code>nil</code></item>
              <item>
                entityDescriptions must have unique
                names
              </item>
              <item>
                for each element in extensions, its owner is not in
                entityDescriptions
              </item>
            </list>
            @section Discussion of Composite and Aggregate
            Terminology in UML
            <p>
              To recap the relationship types from UML:
            </p>
            <deflist>
              <term>association</term>
              <desc>
                a relationship between two objects with no additional
                constraints.
              </desc>
              <term>aggregation</term>
              <desc>
                a type of association, with the constraint that all
                of the pointers in an object graph belonging to
                aggregation relationships form a DAG (this
                doesn’t preclude the relationship being
                many:many). Aggregation represents a
                whole-part relationship, and descendent
                objects in this DAG can be considered a “part
                of” all of their ancestors.
              </desc>
              <term>composition</term>
              <desc>
                a type of aggregation, with the additional constraint
                that an object can only have one composite pointer
                to it at a time (across all incoming relationships).
              </desc>
            </deflist>
            <p>
              I think these definitions are complete, but for more
              info, see "association", "aggregate", and
              "composite" in “The Unified Modeling Language
              Reference Manual”. Note that aggregation and
              composite are just restrictions on the object
              graph, and they are orthogonal to relationship
              cardinality (one:one, one:many, many:many),
              although composite relationships can’t be
              many:many as a consequence of the definition of
              composite.
            </p>
            <p>
              CoreObject implements a subset of the UML
              design with some of our own restrictions: If a
              relationship is many:many, we add no
              additional constraints (it’s a UML
              association). If a relationship is one:many
              or one:one, and bidirectional, we treat it as a UML
              aggregation. Note that CoreObject doesn’t
              support UML the composition constraint described
              above. Unfortunately the CoreObject source code
              uses the term “composite” a lot in ways that don’t
              match UML.
            </p>
            <p>
              Also note that an UML aggregation relationship with
              a one:one/many constraint is similar to UML
              composition; the only difference is that UML
              composition adds the additional constraint
              that the object can have only one incoming composite
              reference across all of its relationships.
            </p>
            <p>
              It could be worth supporting the full UML model, or
              supporting FAME’s model, because CoreObject’s
              current model is a bit weird in that relationship
              cardinality determines object graph
              constraints (association, aggregation,
              composition). For example, in CoreObject
              it’s impossible to model associations that are
              one:one or one:many, but are not aggregations (so
              you want to allow cycles). It’s also strange that a
              relationship in CoreObject can only be
              aggregation if it’s also bidirectional, this
              should probably be changed. However, I'm not sure
              about these points; any changes need to be
              carefully considered, especially with respect
              to COCopier.
            </p>
            <p>
              @section Composite and Aggregate in FAME
            </p>
            <p>
              FAME lacks the aggregation/composition distinction,
              it only has composition. Composition in FAME is almost
              the same as UML (no cycles in the pointers making up
              composite relationships between objects, plus
              every object can only have a single incoming
              composite pointer). For the second condition,
              FAME is slightly stricter in that a
              <strong>Class</strong> can only have a single
              incoming composite relationship, whereas UML
              permits multiple incoming composite relationships
              as <strong>long</strong> as only one of them is
              non-NULL at a time (roughly speaking, UML puts
              the constraint at runtime, FAME puts the constraint
              at compile time).
            </p>
        </desc>
        <ivariable type="BOOL" name="_isFrozen" validity="protected">
          <desc>
            <em>Warning</em> the underscore at the start of the
            name of this instance variable indicates that, even
            though it is not technically <em>private</em>, it is
            intended for internal use within the package, and
            you should not use the variable in other code.
          </desc>
        </ivariable>
        <method type="id" factory="yes">
          <sel>descriptionWithName:</sel>
          <arg type="NSString*">name</arg>
          <desc>
            <p>
              @taskunit Initialization
            </p>
            <p>
              Returns an autoreleased entity, property or
              package description.
            </p>
            <p>
              See also
              <ref type="method" id="-initWithName:">
                -initWithName:
              </ref>
              .
            </p>
          </desc>
        </method>
        <method type="ETEntityDescription*" factory="yes" override="subclass">
          <sel>newEntityDescription</sel>
          <desc>
            <p>
              @taskunit Metamodel Description
            </p>
            <p>
              Returns a new self-description (aka
              meta-metamodel).
            </p>
          </desc>
        </method>
        <method type="void" override="dummy">
          <sel>checkConstraints:</sel>
          <arg type="NSMutableArray*">warnings</arg>
          <desc>
            <p>
              @taskunit Runtime Consistency Check
            </p>
            <p>
              Checks the receiver conforms to the FM3 constraint
              spec and adds a <strong>short</strong> warning to
              the given array for each failure.
            </p>
            <p>
              A warning must be a NSString instance that describes
              the issue. Every warning should be created with
              <ref type="method" id="-warningWithMessage:">
                -warningWithMessage:
              </ref>
              .
            </p>
          </desc>
        </method>
        <method type="void" override="never">
          <sel>checkNotFrozen</sel>
          <desc>
            <p>
              @taskunit Internal
            </p>
            <p>
              Throws an exception if the frozen flag is
              <code>YES</code>. This should be called in
              ETModelElementDescription and
              subclasses before every mutation.
            </p>
          </desc>
        </method>
        <method type="id">
          <sel>init</sel>
          <desc>
            <p>
              Initializes and returns entity, property or
              package description whose name is
              <em>Untitled</em>.
            </p>
          </desc>
        </method>
        <method type="id" init="yes">
          <sel>initWithName:</sel>
          <arg type="NSString*">name</arg>
          <desc>
            <p>
              Initializes and returns an entity, property
              or package description.
            </p>
            <p>
              You must only invoke this method on subclasses,
              otherwise <code>nil</code> is returned.
            </p>
            <p>
              You should pass the property <var>name</var> in
              argument for a property description. And the
              class <var>name</var> for an entity description,
              the only exception is when the entity description
              applies to a prototype rather than a class.
            </p>
            <p>
              Raises an NSInvalidArgumentException when the
              <var>name</var> is <code>nil</code> or already in
              use.
            </p>
          </desc>
        </method>
        <method type="void" override="subclass">
          <sel>makeFrozen</sel>
          <desc>
            <p>
              Marks the receiver as frozen. From this point, the
              receiver is immutable and any attempt to mutate
              it will cause an exception to be thrown.
            </p>
          </desc>
        </method>
        <method type="NSString*">
          <sel>warningWithMessage:</sel>
          <arg type="NSString*">msg</arg>
          <desc>
            <p>
              Returns an autoreleased warning built with the
              given explanation.
            </p>
            <p>
              See
              <ref type="method" id="-checkConstraints:">
                -checkConstraints:
              </ref>
              .
            </p>
          </desc>
        </method>
      </class>
    </chapter>
  </body>
</gsdoc>
