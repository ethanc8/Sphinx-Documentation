<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<title>&Eacute;toil&eacute;</title>
		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<meta name="viewport" content="width = 680" />
		<link rel="stylesheet" href="../_includes/css/reset-fonts-grids.css" type="text/css" />
		<link rel="stylesheet" href="../_includes/css/global.css" type="text/css" />
		<link rel="stylesheet" href="../_includes/css/prettify.css" type="text/css" />
		<link rel="stylesheet" href="../_includes/css/documentation.css" type="text/css" />
		
		<link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/feeds/news/atom/" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<script type="text/javascript" src="../_includes/js/prettify.js"></script>
		<script type="text/javascript" src="../_includes/js/swfobject.js"></script>
		<script type="text/javascript" src="../_includes/js/collapser.js"></script>
	</head>
	<body class="developer" onload="prettyPrint();hideAll();">
	
		<div id="doc3" class="yui-t7">
			
			<div id="hd">
				<div id="nav">
					<ul>
						<li><a href="/"><img src="../images/global/flower.png" alt="&Eacute;toil&eacute; Logo" /></a></li>
						<li><a href="/etoile/">Overview</a></li>
						<li><a href="/downloads/">Downloads</a></li>
						<li><a href="/support/">Support</a></li>
						<li><a href="/news/">News</a></li>
						<li><a href="/dev/">Development</a></li>
					</ul>
				</div>  
			</div> 
			
			<div id="bd" class="team">
			
				<div class="yui-gc" id="masthead">
					<div class="yui-u first">
						<h1><strong>Documentation</strong></h1><p></p>	  
					</div>
				</div>
				
				<div class="yui-gc" id="content">
				
					<div class="yui-u first">
						<div id="main">
							<div id="documentation">
								
								<div class="header">
<h1>NSObject categories documentation</h1><div class="meta">
<p class="metadesc"><em>All the public Categories which extend NSObject class.</em></p><table></table></div>
</div>

								
								<div id="toggler">
									<p id="shower">
									<a href="javascript:void()" onClick="showAll()">&rarr; Expand all</a>
									</p>
									<p id="hider">
									<a href="javascript:void()" onClick="hideAll()">&rarr; Collapse all</a>
									</p>
								</div>
								
								<div class="methodGroup">
<div class="header">
<h2>ETDoubleDispatch</h2>NSObject (ETDoubleDispatch)<div class="meta">
<p class="metadesc"><em>Objective-C <strong>double</strong> dispatch support.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>NSObject+DoubleDispatch.h</td></tr></table></div>
<div class="overview">
<h3>Overview</h3><p><p> This category provides a visitor which supports double-dispatch on all visited objects without implementing extra methods (such as <em>accept:</em> on the visited object side). </p> <p> For a more detailed discussion, see  -visit:  . </p> <p> Here is a visitor example: </p> 
<pre>

@interface ETView : NSView
@end

@interface UIVisitor : NSObject
@end

@implementation ETView

+ (NSString *) typePrefix
{
    return @"ET";
}

@end

// To start using the visitor, instantiate a visitor and do [visitor visit: someWindow]
@implementation UIVisitor

// visitXXX methods return id, but returning void would be valid

- (id) visitWindow: (NSWindow *)aWindow
{
    NSLog(@"Visiting window %@", aWindow);
    return [self visit: [aWindow contentView]];
}

- (id) visitView: (NSView *)aView
{
    NSLog(@"Visiting view %@", aView);
    for (NSView *subview in [aView subviews])
    {
        [self visit: subview];
    }
    return nil;
}

// Show how you can include the class name prefix and how such a method has 
// priority over a method without any type prefix such as -visitView:.
- (id) visitETView: (ETView *)aSpecialView
{
    NSLog(@"Visiting special view %@", aSpecialView);
    return nil;
}

@end
</pre>
</p></div>
</div>
<hr></hr><div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETDoubleDispatch)_doubleDispatchPrefix]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(NSString *)</span><span class="selector"> doubleDispatchPrefix </span></span></dt>
<dd><div class="methodDescription">
<p> Returns the method name prefix used to build the method name to be invoked by the <strong>double</strong> dispatch. </p> <p> By default, returns <em>visit</em>. </p> <p> Can be overriden to return a custom prefix such as <em>visit</em>. </p> <p> See also  -visit:  . </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETDoubleDispatch)_visit:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> visit: </span><span class="parameter"><span class="type">(id)</span><span class="arg">object</span></span></span></dt>
<dd><div class="methodDescription">
<p> Tries to build a method name based on the given <var>object</var> type and invoke it. </p> <p> For example, if you have a NSView, and you pass it as an argument to  -visit:  , the selector <em>visitNSView:</em> is built and invoked with the given view on the receiver. If the receiver doesn't respond to <em>visitNSView:</em> , then <em>visitView:</em> is built by trimming the class name prefix, and invoked. If the receiver still doesn't respond the last built selector, then it fails silently and returns <var>nil</var>. <br></br> <strong>Class</strong> name prefix are trimmed based on the value returned by +[NSObject(Etoile) typePrefix] . You can override this last method to return a custom prefix, by default it returns <em>NS</em>. </p> <p> If you want to use another method name prefix than <em>visit</em> (e.g. to build a selector such as <em>renderView:</em>),  -doubleDispatchPrefix  can be overriden. </p> <p> Subclasses can override this method, if they want to customize the double-dispatch behavior. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETDoubleDispatch)_visit:result:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> visit: </span><span class="parameter"><span class="type">(id)</span><span class="arg">object</span></span><span class="selector"> result: </span><span class="parameter"><span class="type">(BOOL *)</span><span class="arg">performed</span></span></span></dt>
<dd><div class="methodDescription">
<p> Does the same than  -visit:  but reports whether a double-dispatch method was succesfully invoked by setting <var>performed</var> to <var>YES</var>, or <var>NO</var> when no such method was found. </p> <p> See also  -visit:  and -supportsDoubleDispatchWithObject:. </p> <p> This method is called by  -visit:  and implements the double-dispatch logic. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETDoubleDispatch)_supportsDoubleDispatchWithObject:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> supportsDoubleDispatchWithObject: </span><span class="parameter"><span class="type">(id)</span><span class="arg">object</span></span></span></dt>
<dd><div class="methodDescription">
<p> Returns whether the receiver implements a <strong>double</strong> dispatch method that corresponds to the given <var>object</var> type. </p> <p> This method serves a similar purpose than -[NSObject respondsToSelector:] . </p> <p> See also  -visit:  . </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETDoubleDispatch)_doubleDispatchSelectorWithObject:ofType:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(SEL)</span><span class="selector"> doubleDispatchSelectorWithObject: </span><span class="parameter"><span class="type">(id)</span><span class="arg">object</span></span><span class="selector"> ofType: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">aType</span></span></span></dt>
<dd><div class="methodDescription">
<p> Builds and returns the selector to be invoked for a <strong>double</strong> dispatch on the given type. </p> <p> For a detailed example, see  -visit:  . </p> <p> Can be overriden in subclasses to implement an alternative strategy to build the method names targeted by the <strong>double</strong> dispatch. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETDoubleDispatch)_tryToPerformSelector:withObject:result:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> tryToPerformSelector: </span><span class="parameter"><span class="type">(SEL)</span><span class="arg">selector</span></span><span class="selector"> withObject: </span><span class="parameter"><span class="type">(id)</span><span class="arg">object</span></span><span class="selector"> result: </span><span class="parameter"><span class="type">(BOOL *)</span><span class="arg">performed</span></span></span></dt>
<dd><div class="methodDescription">
<p> Tries to invoke the <var>selector</var> with the given <var>object</var> as first argument, and returns either the value returned by the invoked method or <var>nil</var>. </p> <p> If the receiver doesn't respond to the <var>selector</var>, <var>performed</var> is set to <var>NO</var> and <var>nil</var> is returned, otherwise <var>performed</var> is set <var>YES</var>. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETCollectionHOMIntegrationInformalProtocol</h2>NSObject (ETCollectionHOMIntegrationInformalProtocol)<div class="meta">
<p class="metadesc"><em>Procotol to integrate high-order messaging with collections that require special treatments of their elements.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETCollection+HOM.h</td></tr></table></div>
</div>
<div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETCollectionHOMIntegrationInformalProtocol)_collectionArrayAndInfo:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(NSArray *)</span><span class="selector"> collectionArrayAndInfo: </span><span class="parameter"><span class="type">(id*)</span><span class="arg">info</span></span></span></dt>
<dd><div class="methodDescription">
<p> Returns the array representation used to evaluate high-order messages. </p> <p> If not implemented,  -contentArray  is used. </p> <p> If <var>info</var> is not NULL, you can return additional information to be passed to the element-handling hook -placeObject:inCollection:insteadOfObject:atIndex:havingAlreadyMapped:info:. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETEachHOM</h2>NSObject (ETEachHOM)<div class="meta">
<p class="metadesc"><em>Extends <a href="_ETCollection.html#ETCollection">ETCollection</a> to support the 'each' higher-order message.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETCollection+HOM.h</td></tr></table></div>
</div>
<div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETEachHOM)_each]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> each </span></span></dt>
<dd><div class="methodDescription">
<p> If the receiver conforms to the <a href="_ETCollection.html#ETCollection">ETCollection</a> protocol, this method returns a proxy that will let  -map  and -filter methods iterate over the contents of the collection when it is used as an argument to a message. This way, <var> [[people map] sendMail: [messages each]]; </var> will cause the  -sendMail:  message to be executed once with every combination of elements from the <var>people</var> and the <var>messages</var> collection. </p> <p> Note 1: It is only possible to use an proxy object created with  -each  if it is passed as an argument to a message that is send to a higher-order messaging proxy created by  -filter  , -map,  -filteredCollection  or  -mappedCollection  . Doing <var> [aCollection addObject: [things each]] </var> won't do anything. </p> <p> Note 2: If an each proxy is passed to a message used as a filter predicate, it suffices that the predicate evaluates to <var>YES</var> for one element of the argument-collection. If a collection <var>A</var> contains "foo" and "bar" and collection <var>B</var> contains "BAR" and "bar", after <var> [[A filter] isEqualToString: [B each]]; </var> , <var>A</var> will still contain "bar" (but not "BAR"), since one of the elements of <var>B</var> matched "bar". </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETBatchCollectionMutation</h2>NSObject (ETBatchCollectionMutation)<div class="meta">
<p class="metadesc"><em>Optional batch mutation protocol methods for <a href="_ETCollectionMutation.html#ETCollectionMutation">ETCollectionMutation</a>.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETCollection.h</td></tr></table></div>
<div class="overview">
<h3>Overview</h3><p><p> Any mutable collection can also implement the optional methods listed below. </p> <p> EtoileUI will use these methods when possible. <br></br> Initially you can skip implementing them. Later, they can be implemented to speed up the communication between your model collections and the layout items that represent them at the UI level. In addition, these methods allows to react to batch insertion and removal at the model level (e.g. in reply to a pick and drop). </p> <p> You are not required to implement every method when a class adopts this informal protocol. </p> <p> When a collection is received in argument, the collection type can be checked to know whether the code needs to convert the collection or not, to remove or insert its content in the receiver. In most cases, the code below is a useless optimization (the else branch is good enough). </p> 
<pre>
if ([[aCollection content] isArray] == NO)
{
    [personIvarArray addObjectsFromArray: (NSArray *)aCollection];
}
else
{
    [personIvarArray addObjectsFromArray: [aCollection contentArray]];
}
</pre>
 <p> See NSObject+Model for other methods such as  -isArray  . </p></p></div>
</div>
<hr></hr><div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETBatchCollectionMutation)_insertCollection:atIndexes:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> insertCollection: </span><span class="parameter"><span class="type">(id <<a href="_ETCollection.html#ETCollection">ETCollection</a>>)</span><span class="arg">objects</span></span><span class="selector"> atIndexes: </span><span class="parameter"><span class="type">(NSIndexSet *)</span><span class="arg">indexes</span></span></span></dt>
<dd><div class="methodDescription">
<p> Inserts the given collection elements at separate <var>indexes</var>. </p> <p> When the collection is not ordered, the <var>indexes</var> are ignored. </p> <p> The element are inserted one-by-one by increasing index value while iterating over the <var>indexes</var>. When the greatest index is reached and several elements remain to be inserted, they are inserted at that same index. <br></br> For a more precise description of the behavior ordered collection should comply to, see -[NSArray insertObjects:atIndexes:]  in Cocoa documentation. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETBatchCollectionMutation)_removesCollection:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> removesCollection: </span><span class="parameter"><span class="type">(id <<a href="_ETCollection.html#ETCollection">ETCollection</a>>)</span><span class="arg">objects</span></span></span></dt>
<dd><div class="methodDescription">
<p> Removes the elements from the collection. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETBatchCollectionMutation)_removeObjectAtIndexes:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> removeObjectAtIndexes: </span><span class="parameter"><span class="type">(NSIndexSet *)</span><span class="arg">indexes</span></span></span></dt>
<dd><div class="methodDescription">
<p> Removes the elements at the given <var>indexes</var> from the collection. </p> <p> You should only implement this method when the collection is ordered. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETCollectionMutationKVOSupport</h2>NSObject (ETCollectionMutationKVOSupport)<div class="meta">
<p class="metadesc"><em>Unified protocol to post key-value observing change notifications for any collections that conform to <a href="_ETCollection.html#ETCollection">ETCollection</a>.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETCollection.h</td></tr></table></div>
<div class="overview">
<h3>Overview</h3><p><p> This lets you easily change the collection type, without rewriting all the mutation notifications. </p></p></div>
</div>
<hr></hr><div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETCollectionMutationKVOSupport)_willChangeValueForKey:atIndexes:withObjects:mutationKind:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> willChangeValueForKey: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">key</span></span><span class="selector"> atIndexes: </span><span class="parameter"><span class="type">(NSIndexSet *)</span><span class="arg">indexes</span></span><span class="selector"> withObjects: </span><span class="parameter"><span class="type">(NSArray *)</span><span class="arg">objects</span></span><span class="selector"> mutationKind: </span><span class="parameter"><span class="type">(ETCollectionMutationKind)</span><span class="arg">mutationKind</span></span></span></dt>
<dd><div class="methodDescription">
<p> Tells the receiver that the collection bound to the property is about to change. </p> <p> By default, limited to calling: </p> <dl> <dt>  -willChangeValueForKey:  </dt> <dd> NSDictionary, NSMapTable and NSIndexSet </dd> <dt> -willChange:valuesAtIndexes:forKey: </dt> <dd> NSArray, NSPointerArray and NSOrderedSet </dd> <dt> -willChangeValueForKey:withSetMutation:usingObjects: </dt> <dd>NSSet and NSHashTable</dd> </dl> <p> For an ordered collection, the correct index must be passed for each inserted or removed object, otherwise a NSInvalidArgumentException is raised. </p> <p> For an unordered collection, the <var>indexes</var> should be empty. </p> <p> For <var>nil</var> arguments, raises a NSInvalidArgumentException. </p> <p> Can be overriden, but the superclass implementation must be called. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETCollectionMutationKVOSupport)_didChangeValueForKey:atIndexes:withObjects:mutationKind:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> didChangeValueForKey: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">key</span></span><span class="selector"> atIndexes: </span><span class="parameter"><span class="type">(NSIndexSet *)</span><span class="arg">indexes</span></span><span class="selector"> withObjects: </span><span class="parameter"><span class="type">(NSArray *)</span><span class="arg">objects</span></span><span class="selector"> mutationKind: </span><span class="parameter"><span class="type">(ETCollectionMutationKind)</span><span class="arg">mutationKind</span></span></span></dt>
<dd><div class="methodDescription">
<p> Tells the receiver that the collection bound to the property is about to change. </p> <p> By default, limited to calling: </p> <dl> <dt>  -didChangeValueForKey:  </dt> <dd> NSDictionary, NSMapTable and NSIndexSet </dd> <dt> -didChange:valuesAtIndexes:forKey: </dt> <dd> NSArray, NSPointerArray and NSOrderedSet </dd> <dt> -didChangeValueForKey:withSetMutation:usingObjects: </dt> <dd>NSSet and NSHashTable</dd> </dl> <p> For an ordered collection, the correct index must be passed for each inserted or removed object, otherwise a NSInvalidArgumentException is raised. </p> <p> For an unordered collection, the <var>indexes</var> should be empty. </p> <p> For <var>nil</var> arguments, raises a NSInvalidArgumentException. </p> <p> Can be overriden, but the superclass implementation must be called. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETViewpointAdditions</h2>NSObject (ETViewpointAdditions)<div class="meta">
<p class="metadesc"><em>A mechanism to access a represented collection when a viewpoint content is another viewpoint.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETViewpoint.h</td></tr></table></div>
<div class="overview">
<h3>Overview</h3><p><p> This is an unstable API (will probably be removed or changed later). </p></p></div>
</div>
<hr></hr><div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETViewpointAdditions)_isViewpoint]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isViewpoint </span></span></dt>
<dd><div class="methodDescription">
<p> Returns <var>NO</var>. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETViewpointAdditions)_valueForContentKey:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> valueForContentKey: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">key</span></span></span></dt>
<dd><div class="methodDescription">
<em>Description forthcoming.</em><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETViewpointAdditions)_setValue:forContentKey:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> setValue: </span><span class="parameter"><span class="type">(id)</span><span class="arg">aValue</span></span><span class="selector"> forContentKey: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">key</span></span></span></dt>
<dd><div class="methodDescription">
<em>Description forthcoming.</em><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETViewpointAdditions)_valueForContentKeyPath:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> valueForContentKeyPath: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">aKeyPath</span></span></span></dt>
<dd><div class="methodDescription">
<em>Description forthcoming.</em><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETViewpointAdditions)_setValue:forContentKeyPath:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> setValue: </span><span class="parameter"><span class="type">(id)</span><span class="arg">aValue</span></span><span class="selector"> forContentKeyPath: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">aKeyPath</span></span></span></dt>
<dd><div class="methodDescription">
<em>Description forthcoming.</em><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETStackTraceRecorderConveniency</h2>NSObject (ETStackTraceRecorderConveniency)<div class="meta">
<p class="metadesc"><em>Conveniency methods that makes easier to work <a href="ETStackTraceRecorder.html#ETStackTraceRecorder">ETStackTraceRecorder</a>.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETStackTraceRecorder.h</td></tr></table></div>
<div class="overview">
<h3>Overview</h3><p><p> You can use these methods to record stack traces with <a href="ETStackTraceRecorder.html#+[ETStackTraceRecorder_sharedInstance]">+[ETStackTraceRecorder sharedInstance]</a> . </p> <p> For example, in GDB you can type [self recordStackTrace] to keep a trace of the current call stack. <br></br> And you can print all the stack traces recorded for the current object with 'po [[self recordedStackTraces] stringValue]'. </p></p></div>
</div>
<hr></hr><div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETStackTraceRecorderConveniency)_recordStackTrace]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> recordStackTrace </span></span></dt>
<dd><div class="methodDescription">
<p> Records the call stack symbols with the shared stack trace recorder. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETStackTraceRecorderConveniency)_recordedStackTraces]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(NSArray *)</span><span class="selector"> recordedStackTraces </span></span></dt>
<dd><div class="methodDescription">
<p> Returns an array of stack traces previously recorded with the shared stack trace recorded for the receiver. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETPrototypes</h2>NSObject (ETPrototypes)<div class="meta">
<p class="metadesc"><em>Objective-C prototype support.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>NSObject+Prototypes.h</td></tr></table></div>
</div>
<div>
<h3>Default</h3><div class="method">
<a name="+[NSObject(ETPrototypes)_addInstanceMethod:fromBlock:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(BOOL)</span><span class="selector"> addInstanceMethod: </span><span class="parameter"><span class="type">(SEL)</span><span class="arg">aSelector</span></span><span class="selector"> fromBlock: </span><span class="parameter"><span class="type">(id)</span><span class="arg">aBlock</span></span></span></dt>
<dd><div class="methodDescription">
<p> Adds an instance method to the class, using the specified block. The types for the method are inferred from the block. </p> <p> The block must take an object (self) as the first argument. Any subsequent arguments are the explicit arguments to the method. The _cmd argument is not available for methods added in this way. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="+[NSObject(ETPrototypes)_addClassMethod:fromBlock:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(BOOL)</span><span class="selector"> addClassMethod: </span><span class="parameter"><span class="type">(SEL)</span><span class="arg">aSelector</span></span><span class="selector"> fromBlock: </span><span class="parameter"><span class="type">(id)</span><span class="arg">aBlock</span></span></span></dt>
<dd><div class="methodDescription">
<p> Adds a class method to the class, using the specified block. The types for the method are inferred from the block. </p> <p> The block must take an object (self) as the first argument. Any subsequent arguments are the explicit arguments to the method. The _cmd argument is not available for methods added in this way. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPrototypes)_addMethod:fromBlock:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> addMethod: </span><span class="parameter"><span class="type">(SEL)</span><span class="arg">aSelector</span></span><span class="selector"> fromBlock: </span><span class="parameter"><span class="type">(id)</span><span class="arg">aBlock</span></span></span></dt>
<dd><div class="methodDescription">
<p> Adds a method to the receiver, using the specified block. The types for the method are inferred from the block. </p> <p> The block must take an object (self) as the first argument. Any subsequent arguments are the explicit arguments to the method. The _cmd argument is not available for methods added in this way. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPrototypes)_setMethod:forSelector:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> setMethod: </span><span class="parameter"><span class="type">(IMP)</span><span class="arg">aMethod</span></span><span class="selector"> forSelector: </span><span class="parameter"><span class="type">(SEL)</span><span class="arg">aSelector</span></span></span></dt>
<dd><div class="methodDescription">
<p> Adds the specified method to this instance. Objects modified in this way get a hidden dictionary for non-indexed instance variables, allowing them to use KVC to set arbitrary objects on self. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPrototypes)_clone]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> clone </span></span></dt>
<dd><div class="methodDescription">
<p> Returns a clone of the object. The clone will inherit all methods and associated objects. To copy instance variables, you must override this method. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPrototypes)_isPrototype]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isPrototype </span></span></dt>
<dd><div class="methodDescription">
<p> Returns <var>YES</var> if this object inherits from another object. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPrototypes)_prototype]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> prototype </span></span></dt>
<dd><div class="methodDescription">
<p> Returns the prototype for this object, or <var>nil</var> if this object does not have one. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPrototypes)_slotValueForKey:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> slotValueForKey: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">aKey</span></span></span></dt>
<dd><div class="methodDescription">
<p> Does the same as valueForKey:, except when this object is a prototype and a block closure is associated with the supplied key. The block closure is then returned without being invoked. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETListenSocketDelegate</h2>NSObject (ETListenSocketDelegate)<div class="meta">
<p class="metadesc"><em>Informal protocol for delegates to listening sockets.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETSocket.h</td></tr></table></div>
</div>
<div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETListenSocketDelegate)_newConnection:fromSocket:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> newConnection: </span><span class="parameter"><span class="type">(<a href="ETSocket.html#ETSocket">ETSocket</a> *)</span><span class="arg">aSocket</span></span><span class="selector"> fromSocket: </span><span class="parameter"><span class="type">(<a href="ETSocket.html#ETSocket">ETSocket</a> *)</span><span class="arg">listenerSocket</span></span></span></dt>
<dd><div class="methodDescription">
<p> Handle a new connection request received by <var>listenerSocket</var>. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETSocketDelegate</h2>NSObject (ETSocketDelegate)<div class="meta">
<p class="metadesc"><em>Informal protocol for socket delegates.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETSocket.h</td></tr></table></div>
</div>
<div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETSocketDelegate)_receivedData:fromSocket:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(void)</span><span class="selector"> receivedData: </span><span class="parameter"><span class="type">(NSData *)</span><span class="arg">aData</span></span><span class="selector"> fromSocket: </span><span class="parameter"><span class="type">(<a href="ETSocket.html#ETSocket">ETSocket</a> *)</span><span class="arg">aSocket</span></span></span></dt>
<dd><div class="methodDescription">
<p> Handle data received over the specified socket. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETModel</h2>NSObject (ETModel)<div class="meta">
<p class="metadesc"><em>NSObject additions providing basic management of model objects.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>NSObject+Model.h</td></tr></table></div>
</div>
<div>
<h3>Providing the Metamodel</h3><div class="method">
<a name="+[NSObject(ETModel)_newEntityDescription]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(<a href="ETEntityDescription.html#ETEntityDescription">ETEntityDescription</a> *)</span><span class="selector"> newEntityDescription </span></span></dt>
<dd><div class="methodDescription">
<p> Returns a new self-description (aka metamodel). </p> <p> You must never use this method to retrieve an entity description, but only retrieves it through a <a href="ETModelDescriptionRepository.html#ETModelDescriptionRepository">ETModelDescriptionRepository</a> instance. </p> <p> This method can be invoked at runtime by a repository to automatically collect the entity descriptions and make them available in this repository. </p> <p> You can implement this method to describe your subclasses more precisely than  -basicNewEntityDescription  . <br></br> You must never call [super newEntityDescription] in the implementation. <br></br> You must not return an autoreleased object. </p> <p> For example: </p> 
<pre>
ETEntityDescription *desc = [self newBasicEntityDescription];

// For subclasses that don't override -newEntityDescription, we must not add the 
// property descriptions that we will inherit through the parent (the 
// 'MyClassName' entity description).
if ([[desc name] isEqual: [MyClass className]] == NO) return desc;

ETPropertyDescription *city = [ETPropertyDescription descriptionWithName: @"city" type: (id)@"NSString"];
ETPropertyDescription *country = [ETPropertyDescription descriptionWithName: @"country" type: (id)@"NSString"];

[desc setPropertyDescriptions: A(city, country)];

[desc setAbstract: YES];

return desc;
</pre>
 <p> If you want set the parent explicitly, replace  -newBasicEntityDescription  with: </p> 
<pre>
ETEntityDescription *desc = [ETEntityDescription descriptionWithName: [self className]];

// Will be resolved when the entity description is put in the repository
[desc setParent: NSStringFromClass([self superclass])];
</pre>
 <br></br> <p> Returns a new self-description (aka metamodel). </p> <p> You must never use this method to retrieve an entity description, but only retrieves it through a <a href="ETModelDescriptionRepository.html#ETModelDescriptionRepository">ETModelDescriptionRepository</a> instance. </p> <p> This method can be invoked at runtime by a repository to automatically collect the entity descriptions and make them available in this repository. </p> <p> You can implement this method to describe your subclasses more precisely than  -basicNewEntityDescription  . <br></br> You must never call [super newEntityDescription] in the implementation. <br></br> You must not return an autoreleased object. </p> <p> For example: </p> 
<pre>
ETEntityDescription *desc = [self newBasicEntityDescription];

// For subclasses that don't override -newEntityDescription, we must not add the 
// property descriptions that we will inherit through the parent (the 
// 'MyClassName' entity description).
if ([[desc name] isEqual: [MyClass className]] == NO) return desc;

ETPropertyDescription *city = [ETPropertyDescription descriptionWithName: @"city" type: (id)@"NSString"];
ETPropertyDescription *country = [ETPropertyDescription descriptionWithName: @"country" type: (id)@"NSString"];

[desc setPropertyDescriptions: A(city, country)];

[desc setAbstract: YES];

return desc;
</pre>
 <p> If you want set the parent explicitly, replace  -newBasicEntityDescription  with: </p> 
<pre>
ETEntityDescription *desc = [ETEntityDescription descriptionWithName: [self className]];

// Will be resolved when the entity description is put in the repository
[desc setParent: NSStringFromClass([self superclass])];
</pre>
<div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="+[NSObject(ETModel)_newBasicEntityDescription]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(<a href="ETEntityDescription.html#ETEntityDescription">ETEntityDescription</a> *)</span><span class="selector"> newBasicEntityDescription </span></span></dt>
<dd><div class="methodDescription">
<p> Returns a new minimal self-description without any property descriptions. </p> <p> This entity description uses the class name as its name and the parent name is set to the superclass name. The owner name is set to the bundle identifier (or executable path in last resort). </p> <p> The parent and owner will be resolved by <a href="ETModelDescriptionRepository.html#-[ETModelDescriptionRepository_resolveNamedObjectReferences]">-[ETModelDescriptionRepository resolveNamedObjectReferences]</a> . </p> <p> You must never use this method to retrieve an entity description, but only a <a href="ETModelDescriptionRepository.html#ETModelDescriptionRepository">ETModelDescriptionRepository</a> instance to do so. </p> <p> The returned object is not autoreleased. </p> <p> See also  -newEntityDescription  , -[ETEntityDescription parentName]  and -[ETEntityDescription ownerName] . </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<h3>Common Representations</h3><div class="method">
<a name="-[NSObject(ETModel)_objectValue]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> objectValue </span></span></dt>
<dd><div class="methodDescription">
<em>Description forthcoming.</em><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_isCommonObjectValue]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isCommonObjectValue </span></span></dt>
<dd><div class="methodDescription">
<p> Returns <var>YES</var> when the receiver is an object which can be passed to  -setObjectValue:  or returned by  -objectValue  . Some common object values like string and number can be displayed and edited transparently (in an NSCell instance to take an example). If you define additional common object values, you usually have to write related formatters. Returns <var>NO</var> by default. Subclasses can override this method to specify an object can be accepted and used a common object value. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_isString]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isString </span></span></dt>
<dd><div class="methodDescription">
<p> Returns <var>YES</var> if the receiver is an NSString instance, otherwise returns <var>NO</var>. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_isNumber]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isNumber </span></span></dt>
<dd><div class="methodDescription">
<p> Returns <var>YES</var> if the receiver is an NSNumber instance, otherwise returns <var>NO</var>. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<h3>Basic Properties</h3><div class="method">
<a name="-[NSObject(ETModel)_displayName]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(NSString *)</span><span class="selector"> displayName </span></span></dt>
<dd><div class="methodDescription">
<p> Returns the receiver description. Subclasses can override this method to return a more appropriate display name. </p> <p> Returns the receiver description. Subclasses can override this method to return a more appropriate display name. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_primitiveDescription]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(NSString *)</span><span class="selector"> primitiveDescription </span></span></dt>
<dd><div class="methodDescription">
<p> Returns the description as NSObject would. This method returns the same value as  -description  if the latter method isn't overriden in your subclasses, otherwise it returns the value that  -description  would return if you haven't overriden it. Useful to get consistent <strong>short</strong> descriptions on all instances and can be used to provide custom description built with other <strong>short</strong> descriptions. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_descriptionWithOptions:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(NSString *)</span><span class="selector"> descriptionWithOptions: </span><span class="parameter"><span class="type">(NSMutableDictionary *)</span><span class="arg">options</span></span></span></dt>
<dd><div class="methodDescription">
<p> Returns a description generated based on the given <var>options</var>. </p> <p> Might describe a tree or graph structure if a traversal key is provided to recursively invoke  -descriptionsWithOptions:  on each object node. To do so, put ETDescriptionOptionTraversalKey with a valid KVC key in the <var>options</var>. You can also set a max depth with ETDescriptionOptionMaxDepth to limit the description size or end a graph traversal. </p> <p> You can collect key path values on each object node by specifying an array of key paths with ETDescriptionOptionValuesForKeyPaths. </p> <p> The description format is roughly: depth based indentation + object <strong>short</strong> description + keyPath1: value1, keyPath2: value2 etc. </p> <p> By default,  -description  is used to print both object <strong>short</strong> description and key path values. </p> <p> For customizing the object <strong>short</strong> description, put kETDescriptionOptionShortDescriptionSelector with a custom selector string in the <var>options</var> (-description is then used as fallback). <br></br> If you override  -description  to call  -descriptionWithOptions:  , you must provide a valid kETDescriptionOptionShortDescriptionSelector to prevent an endless loop (for example, just use -primitiveDescription). </p> <p> For presenting each key path on a new line, put kETDescriptionOptionPropertyIndent with a tab string in the <var>options</var>. </p> <p> Here is an example based on EtoileUI that dumps an item tree structure: </p> 
<pre>
// ObjC code
ETLog(@"\n%@\n", [browserItem descriptionWithOptions: [NSMutableDictionary dictionaryWithObjectsAndKeys: 
    A(@"frame", @"autoresizingMask"), kETDescriptionOptionValuesForKeyPaths,
    @"items", kETDescriptionOptionTraversalKey, nil]]);

// Console Output
&lt;ETLayoutItemGroup: 0x9e7b268&gt; { frame: {x = 0; y = 0; width = 600; height = 300}, autoresizingMask: 18 }
    &lt;ETLayoutItemGroup: 0x9fbea48&gt; { frame: {x = 0; y = 0; width = 1150; height = 53}, autoresizingMask: 2 }
        &lt;ETLayoutItem: 0x9f29240&gt; { frame: {x = 12; y = 12; width = 100; height = 22}, autoresizingMask: 0 }
        &lt;ETLayoutItem: 0x9e6fcf0&gt; { frame: {x = 124; y = 12; width = 100; height = 24}, autoresizingMask: 0 }
    &lt;ETLayoutItemGroup: 0x9fac170&gt; { frame: {x = 0; y = 0; width = 1150; height = 482}, autoresizingMask: 18 }
        &lt;ETLayoutItemGroup: 0x9fb2870&gt; { frame: {x = 0; y = 0; width = 50; height = 50}, autoresizingMask: 0 }
</pre>
 <p> <var>options</var> must not be <var>nil</var>, otherwise raises an NSInvalidArgumentException. </p> <p> You can override this method in subclasses, although it is not advised to. The <var>options</var> dictionary can be changed arbitrarily in a new implementation. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<h3>KVO Syntactic Sugar (Unstable API)</h3><div class="method">
<a name="-[NSObject(ETModel)_observableKeyPaths]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(NSSet *)</span><span class="selector"> observableKeyPaths </span></span></dt>
<dd><div class="methodDescription">
<p> Returns an empty set. <br></br> Overrides to return the receiver key paths to be observed when an observer is set up with  -addObserver:  . <br></br> </p> <p> The returned set content must not change during the whole object lifetime, otherwise  -removeObserver:  will crash randomly. </p> <p> Returns an empty set. <br></br> Overrides to return the receiver key paths to be observed when an observer is set up with  -addObserver:  . <br></br> </p> <p> The returned set content must not change during the whole object lifetime, otherwise  -removeObserver:  will crash randomly. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<h3>Collection and Mutability</h3><div class="method">
<a name="+[NSObject(ETModel)_mutableClass]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(Class)</span><span class="selector"> mutableClass </span></span></dt>
<dd><div class="methodDescription">
<p> Returns a mutable counterpart class or Nil if such a class does not exist. </p> <p> Returns a mutable counterpart class or Nil if such a class does not exist. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_isMutable]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isMutable </span></span></dt>
<dd><div class="methodDescription">
<p> Returns <var>YES</var> if the receiver is declared as mutable, otherwise returns <var>NO</var>. </p> <p> This method returns <var>NO</var> by default. You can override it to return <var>YES</var> if you want to declare your subclass instances as mutable objects (which are collections most of time). </p> <p> If you adopts <a href="_ETCollectionMutation.html#ETCollectionMutation">ETCollectionMutation</a> in a subclass, you don't need to override this method to declare your collection objects as mutable. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_isCollection]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isCollection </span></span></dt>
<dd><div class="methodDescription">
<p> Returns <var>YES</var> if the receiver is declared as a collection by conforming to <a href="_ETCollection.html#ETCollection">ETCollection</a> protocol, otherwise returns <var>NO</var>. </p> <p> You must never override this method in your collection classes, you only need to adopt <a href="_ETCollection.html#ETCollection">ETCollection</a> protocol. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_isMutableCollection]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isMutableCollection </span></span></dt>
<dd><div class="methodDescription">
<p> Returns <var>YES</var> if the receiver is declared as a collection by conforming to <a href="_ETCollectionMutation.html#ETCollectionMutation">ETCollectionMutation</a> protocol, otherwise returns <var>NO</var>. </p> <p> You must never override this method in your collection classes, you only need to adopt <a href="_ETCollectionMutation.html#ETCollectionMutation">ETCollectionMutation</a> protocol. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_isPrimitiveCollection]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isPrimitiveCollection </span></span></dt>
<dd><div class="methodDescription">
<p> Returns <var>YES</var> if the receiver is a low-level collection such as NSArray, NSet, etc., otherwise returns <var>NO</var>. </p> <p> For a model object such as ETLayoutItemGroup that conforms to <a href="_ETCollection.html#ETCollection">ETCollection</a> protocol, would return <var>NO</var>. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_isGroup]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isGroup </span></span></dt>
<dd><div class="methodDescription">
<p> Returns <var>YES</var> if the receiver is declared as a group, otherwise returns <var>NO</var>. </p> <p> This method returns <var>NO</var> by default. You can override it to return <var>YES</var> if you want to declare your subclass instances as groups. </p> <p> A group is specialized model object which is a composite and can behave like a mutable collection. A basic collection object (like NSMutableArray, NSMutableDictionary, NSMutableSet) must never be declared as a group. <br></br> COGroup in CoreObject or ETLayoutItemGroup in EtoileUI are typical examples. </p> <p> A group should conform to <a href="_ETCollectionMutation.html#ETCollectionMutation">ETCollectionMutation</a> protocol. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETModel)_insertionKeyForCollection:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> insertionKeyForCollection: </span><span class="parameter"><span class="type">(id <<a href="_ETKeyedCollection.html#ETKeyedCollection">ETKeyedCollection</a>>)</span><span class="arg">aCollection</span></span></span></dt>
<dd><div class="methodDescription">
<p> Returns a key for inserting the receiver into the given keyed collection. </p> <p> By default, returns a key built by incrementing the integer value in the 'Unknown &lt;number&gt;' pattern, until it provides a key not yet in use in the collection argument. </p> <p> This key is retrieved by a collection in reply to  -insertObjects:atIndexes:hints:  of <a href="_ETCollectionMutation.html#ETCollectionMutation">ETCollectionMutation</a> protocol. You can return different keys depending on the type of collection. This parameter is usually the mutated collection itself. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETKeyValuePair</h2>NSObject (ETKeyValuePair)<div class="meta">
<p class="metadesc"><em>ETKeyValuePair-related extensions to NSObject.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETKeyValuePair.h</td></tr></table></div>
</div>
<div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETKeyValuePair)_isKeyValuePair]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isKeyValuePair </span></span></dt>
<dd><div class="methodDescription">
<p> Returns whether the receiver is a <a href="ETKeyValuePair.html#ETKeyValuePair">ETKeyValuePair</a> instance. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>Etoile</h2>NSObject (Etoile)<div class="meta">
<p class="metadesc"><em>NSObject basic reflection additions.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>NSObject+Etoile.h</td></tr></table></div>
<div class="overview">
<h3>Overview</h3><p><p> This category extends NSObject reflection API in a minimal way. </p> <p> The true Etoile reflection API is declared in ETReflection.h. </p></p></div>
</div>
<hr></hr><div>
<h3>Default</h3><div class="method">
<a name="+[NSObject(Etoile)_allSubclasses]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(NSArray *)</span><span class="selector"> allSubclasses </span></span></dt>
<dd><div class="methodDescription">
<p> Returns all descendant subclasses of the receiver class. </p> <p> The returned array doesn't include the receiver class. </p> <p> You should rather use -[ETClassMirror allSubclassMirrors] , this method could be deprecated in the future. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="+[NSObject(Etoile)_directSubclasses]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(NSArray *)</span><span class="selector"> directSubclasses </span></span></dt>
<dd><div class="methodDescription">
<p> Returns all subclasses which inherit directly from the receiver class. </p> <p> Subclasses that belongs to the class hierarchy of the receiver class but whose superclasses aren't equal to it, are excluded. </p> <p> The returned array doesn't include the receiver class. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(Etoile)_UTI]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(<a href="ETUTI.html#ETUTI">ETUTI</a> *)</span><span class="selector"> UTI </span></span></dt>
<dd><div class="methodDescription">
<p> Returns the uniform type identifier of the object. </p> <p> The UTI object encodes the type of the object in term of namespaces and multiple inheritance. </p> <p> By default, the UTI object is shared by all instances by being built from the class name. If you need to introduce type at instance level, you can do it by overriding this method. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(Etoile)_typeName]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(NSString *)</span><span class="selector"> typeName </span></span></dt>
<dd><div class="methodDescription">
<p> Returns the type name which is the last component of the string value returned by the receiver UTI object. </p> <p> See also -UTI. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="+[NSObject(Etoile)_typePrefix]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(NSString *)</span><span class="selector"> typePrefix </span></span></dt>
<dd><div class="methodDescription">
<p> Returns the type prefix, usually the prefix part of the type name returned by  -className  . </p> <p> By default, returns 'NS'. </p> <p> You must override this method in your subclass to indicate the prefix of your new class name. Take note the prefix will logically apply to every subsequent subclasses inheriting from the class that redefines  -typePrefix  . </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(Etoile)_className]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(NSString *)</span><span class="selector"> className </span></span></dt>
<dd><div class="methodDescription">
<p> Returns the class name. </p> <p> This Foundation method is missing on iOS. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETTrait</h2>NSObject (ETTrait)<div class="meta">
<p class="metadesc"><em>Objective-C trait support.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>NSObject+Trait.h</td></tr></table></div>
<div class="overview">
<h3>Overview</h3><p><p> Adds traits to Objective-C, to support class composition, in addition to inheritance. Traits allow methods to be added to another class. </p> <p> The trait support in EtoileFoundation is based on: </p> <ul> <li> http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf (original and <strong>short</strong> one) </li> <li> http://scg.unibe.ch/archive/papers/Duca06bTOPLASTraits.pdf (most recent and quite lengthy) </li> </ul> <p> To get an introduction to the trait model and its various rules, you should read the <strong>short</strong> paper listed above. </p> <h4> Objective-C Trait Overview and Restrictions </h4> <p> The trait API supports both trait operators (exclusion, aliasing) and composite trait (a trait with subtraits). However there are two important restrictions: </p> <ul> <li> the super keyword must not be used in a trait method </li> <li> instances variables must not be accessed directly but only through accessors </li> </ul> <p> If these restrictions are ignored, the code may compile, but will surely result in a buggy behavior at runtime. </p> <p> With the current implementation, the limitations below should be kept in mind: </p> <ul> <li> trait applications don't take in account class methods </li> <li> no mechanism to declare and check non-trait methods required by trait methods (so you get a runtime exception instead) </li> </ul> <h4> Basic example and Terminology </h4> <p> To apply a trait, the basic API is  +applyTraitFromClass:  , and we use the terminology below: </p> <dl> <dt>trait class</dt> <dd> the class which represents a trait and whose methods are called trait methods. The superclass methods are ignored if the class is used as a trait </dd> <dt>target class</dt> <dd> the class to which a trait class is applied to </dd> <dt>trait application</dt> <dd> a trait use that involves a trait class, a target class and operator-related arguments </dd> </dl> <p> For example: </p> 
<pre>
// Traits should be applied as early as possible usually, that's why we use +initialize
+ (void) initialize
{
    if (self != [MyClass class])
        return;

    [aTargetClass applyTraitFromClass: aTraitClass];
}
</pre>
 <h4> Detailed Examples </h4> <p> Here is a more complex example that applies two subtraits (BasicTrait and ComplexTrait) to another trait (CompositeTrait), then the resulting is applied to the target class (the receiver's class). </p> 
<pre>
    // -wanderWhere: from Basic method will be renamed -lost: in CompositeTrait
    [[CompositeTrait class] applyTraitFromClass: [BasicTrait class]
                            excludedMethodNames: S(@"isOrdered")
                             aliasedMethodNames: D(@"lost:", @"wanderWhere:")];

    [[CompositeTrait class] applyTraitFromClass: [ComplexTrait class]];

    [[self class] applyTraitFromClass: [CompositeTrait class]];
</pre>
 <p> As a concrete example, collection protocols are now implemented by most classes in Étoilé frameworks through two new <a href="ETCollectionTrait.html#ETCollectionTrait">ETCollectionTrait</a> and <a href="ETMutableCollectionTrait.html#ETMutableCollectionTrait">ETMutableCollectionTrait</a>. </p> <h4> Trait Validation </h4> <p> Trait applications are memorized to support composite traits and multiple trait applications to the same target class. Each time a trait is applied, it gets validated against the trait tree already bound to the target class. This ensures operators, overriding rule and flattening property will remain valid in the new trait tree. Unlike Squeak trait support, a trait can be applied at any time. </p> <h4> Mixin-style Application </h4> <p> In addition, it's possible to apply a trait without the overriding rule (that states target class overrides trait methods), which means methods in the target class can be replaced by methods from a trait. </p> 
<pre>
    // With YES, we allow the trait to override/replace methods in the target class
    [[self class] applyTraitFromClass: [BasicTrait class]
                  excludedMethodNames: S(@"isOrdered")
                   aliasedMethodNames: D(@"lost:", @"wanderWhere:")
                       allowsOverride: YES];
</pre>
 <p> Trait applications are commutative, so the ordering in which you apply traits doesn't matter… but when this mixin-style composition is used, traits are not commutative and the ordering matters. That's why we'd rather discourage its use. </p></p></div>
</div>
<hr></hr><div>
<h3>Default</h3><div class="method">
<a name="+[NSObject(ETTrait)_applyTraitFromClass:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(void)</span><span class="selector"> applyTraitFromClass: </span><span class="parameter"><span class="type">(Class)</span><span class="arg">aClass</span></span></span></dt>
<dd><div class="methodDescription">
<p> Apply <var>aClass</var> to this class as a trait. </p> <p> Raises exceptions if the trait application cannot be validated. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="+[NSObject(ETTrait)_applyTraitFromClass:excludedMethodNames:aliasedMethodNames:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(void)</span><span class="selector"> applyTraitFromClass: </span><span class="parameter"><span class="type">(Class)</span><span class="arg">aClass</span></span><span class="selector"> excludedMethodNames: </span><span class="parameter"><span class="type">(NSSet *)</span><span class="arg">excludedNames</span></span><span class="selector"> aliasedMethodNames: </span><span class="parameter"><span class="type">(NSDictionary *)</span><span class="arg">aliasedNames</span></span></span></dt>
<dd><div class="methodDescription">
<p> Apply <var>aClass</var> to this class as a trait, without the trait methods listed in <var>excludedNames</var>, and by renaming the trait methods with the name values provided in the <var>aliasedNames</var> dictionary (where keys should be the existing trait method names). </p> <p> Raises exceptions if the trait application cannot be validated. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="+[NSObject(ETTrait)_applyTraitFromClass:excludedMethodNames:aliasedMethodNames:allowsOverride:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">+ </span><span class="returnType">(void)</span><span class="selector"> applyTraitFromClass: </span><span class="parameter"><span class="type">(Class)</span><span class="arg">aClass</span></span><span class="selector"> excludedMethodNames: </span><span class="parameter"><span class="type">(NSSet *)</span><span class="arg">excludedNames</span></span><span class="selector"> aliasedMethodNames: </span><span class="parameter"><span class="type">(NSDictionary *)</span><span class="arg">aliasedNames</span></span><span class="selector"> allowsOverride: </span><span class="parameter"><span class="type">(BOOL)</span><span class="arg">override</span></span></span></dt>
<dd><div class="methodDescription">
<p> Does the same than +applyTraitFromClass:excludedMethodNames:aliasedMethodNames: but allows to replace methods in the target class with trait methods if <var>YES</var> is passed as the last argument. </p> <p> By default, the trait overriding rule states that trait methods cannot replace methods that belongs to the target class, but only hide methods declared in superclasses and inherited by the target class. </p> <p> If <var>YES</var> is passed and there are other traits applied to the target class, the ordering use to apply traits cannot be ignored anymore. </p> <p> Raises exceptions if the trait application cannot be validated. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETHOM</h2>NSObject (ETHOM)<div class="meta">
<p class="metadesc"><em>High-order messaging additions to NSObject.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>NSObject+HOM.h</td></tr></table></div>
</div>
<div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETHOM)_ifResponds]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> ifResponds </span></span></dt>
<dd><div class="methodDescription">
<p> Returns the receiver itself when it can respond to the next message that follows  -ifResponds  , otherwise returns <var>nil</var>. </p> <p> If we suppose the Cat class doesn't implement  -bark  , then  -ifResponds  would return <var>nil</var> and thereby  -bark  be discarded: <var>[[cat ifResponds] bark];</var> </p> <p> Now let's say the Dog class implement  -bark  , the  -ifResponds  will return 'dog' and  -bark  be executed: <var>[[dog ifResponds] bark];</var> </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETIndexValuePair</h2>NSObject (ETIndexValuePair)<div class="meta">
<p class="metadesc"><em>ETIndexValuePair-related extensions to NSObject.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETIndexValuePair.h</td></tr></table></div>
</div>
<div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETIndexValuePair)_isIndexValuePair]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> isIndexValuePair </span></span></dt>
<dd><div class="methodDescription">
<p> Returns whether the receiver is an index-value pair. By default, returns <var>NO</var>. See also <a href="ETIndexValuePair.html#-[ETIndexValuePair_isIndexValuePair]">-[ETIndexValuePair isIndexValuePair]</a> . </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>
<div class="methodGroup">
<div class="header">
<h2>ETPropertyValueCoding</h2>NSObject (ETPropertyValueCoding)<div class="meta">
<p class="metadesc"><em>Protocol to read and write properties.</em></p><table><tr><th>Authors</th><td>Generated by pi </td></tr><tr><th>Declared in</th><td>ETPropertyValueCoding.h</td></tr></table></div>
<div class="overview">
<h3>Overview</h3><p><p> Property-Value Coding allows to access properties of objects in a uniform manner, while still supporting Key-Value Coding. </p> <p> Key-Value Coding is similar but tends to be overriden in many subclasses. As a result, <var>-[NSDictionary valueForKey: @"count"]</var> doesn't return the count value, but attemps to look a value using [NSDictionary objectForKey: @"count"]. So Key-Value Coding doesn't constitute a mechanism versatile enough to introspect or access object properties. In addition,  -valueForKey:  doesn't accept invalid key unlike  -valueForProperty:  . This is important for presenting unrelated objects in a table UI (mapping properties to columns) where each object has its own property set. More generally this matters for manipulating properties of unrelated objects using the same code. </p> <p> ETPropertyValueCoding protocol is usually adopted by root object classes such as NSObject and overriden in subclasses. See NSObject(Model). </p> <p> The basic behavior of the Property-Value-Coding is implemented in NSObject(ETModelAdditions), but few classes such as <a href="ETMutableObjectViewpoint.html#ETMutableObjectViewpoint">ETMutableObjectViewpoint</a> and ETLayoutItem in EtoileUI overrides the NSObject semantic for  -valueForProperty:  and  -setValue:forProperty:  . </p></p></div>
</div>
<hr></hr><div>
<h3>Default</h3><div class="method">
<a name="-[NSObject(ETPropertyValueCoding)_requiresKeyValueCodingForAccessingProperties]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> requiresKeyValueCodingForAccessingProperties </span></span></dt>
<dd><div class="methodDescription">
<p> Can be overriden to return <var>YES</var> in order to support exposing properties, in case  -valueForProperty:  and  -setValue:forProperty:  access another object and not the receiver. </p> <p> This method is used by <a href="ETMutableObjectViewpoint.html#ETMutableObjectViewpoint">ETMutableObjectViewpoint</a> to determine whether the receiver represented property can be accessed through  -valueForProperty:  or  -valueForKey:  . </p> <p> By default, returns <var>NO</var>. </p> <p> If  -valueForProperty:  and  -setValue:forProperty:  don't access a represented object, there is not need to override this method to return <var>YES</var> in subclasses. You usually never need to override this method unless you adopt <a href="_ETPropertyViewpoint.html#ETPropertyViewpoint">ETPropertyViewpoint</a> protocol. </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPropertyValueCoding)_propertyNames]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(NSArray *)</span><span class="selector"> propertyNames </span></span></dt>
<dd><div class="methodDescription">
<p> Returns the names of the properties exposed by the receiver through  -valueForProperty:  and  -setValue:forProperty:  , or  -valueForKey:  and  -setValue:forKey:  if -requiresKeyValueCodingForAccessingProperties returns <var>YES</var>. </p> <p> Returns both the property names bound to the object entity description and the basic property names. </p> <p> <a href="ETModelDescriptionRepository.html#+[ETModelDescriptionRepository_mainRepository]">+[ETModelDescriptionRepository mainRepository]</a>  is used to look up the entity description. </p> <p> To be exposed through Property Value Coding, the receiver properties must be listed among the returned properties. </p> <p> Can be overriden to return property names bound to entity descriptions that don't belong to the main repository, or filter some properties out. In the overriden method, you should usually return  -basicPropertyNames  along the property description names. </p> <p> For a NSObject subclass not bound to an entity description, the property names related to the closest superclass bound to an entity description are returned through a recursive lookup in  -entityDescriptionForClass:  . </p> <p> See  -basicPropertyNames  ,  -valueForProperty:  and  -setValue:forProperty:  . See also -[ETPropertyValueCoding propertyNames] . </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPropertyValueCoding)_valueForProperty:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> valueForProperty: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">key</span></span></span></dt>
<dd><div class="methodDescription">
<p> Returns the value of the property. </p> <p> If the property doesn't exist, returns <var>nil</var> but must not raise an exception. </p> <p> The method precise semantic is under the control of the class implementing the protocol. For example, the property can belong to another object than the receiver. </p> <p> See also <a href="NSObjectCategories.html#-[NSObject_valueForProperty:]">-[NSObject valueForProperty:]</a>  and -[ETPropertyViewpoint valueForProperty:] . </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPropertyValueCoding)_setValue:forProperty:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> setValue: </span><span class="parameter"><span class="type">(id)</span><span class="arg">value</span></span><span class="selector"> forProperty: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">key</span></span></span></dt>
<dd><div class="methodDescription">
<p> Sets the <var>value</var> of the property and returns <var>YES</var> if the <var>value</var> was successfully set. </p> <p> If the property doesn't exist, returns <var>NO</var> but must not raise an exception. </p> <p> The method precise semantic is under the control of the class implementing the protocol. </p> <p> See also <a href="NSObjectCategories.html#-[NSObject_setValue:forProperty:]">-[NSObject setValue:forProperty:]</a>  and -[ETPropertyViewpoint setValue:forProperty:] . </p><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPropertyValueCoding)_valueForPropertyPath:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(id)</span><span class="selector"> valueForPropertyPath: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">aPropertyPath</span></span></span></dt>
<dd><div class="methodDescription">
<em>Description forthcoming.</em><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
<div class="method">
<a name="-[NSObject(ETPropertyValueCoding)_setValue:forPropertyPath:]"></a><dl class="collapsable">
<dt>
<span class="methodSignature"><span class="methodScope">- </span><span class="returnType">(BOOL)</span><span class="selector"> setValue: </span><span class="parameter"><span class="type">(id)</span><span class="arg">aValue</span></span><span class="selector"> forPropertyPath: </span><span class="parameter"><span class="type">(NSString *)</span><span class="arg">aPropertyPath</span></span></span></dt>
<dd><div class="methodDescription">
<em>Description forthcoming.</em><div class="paramsList">
<ul></ul></div>
</div>
</dd></dl>
</div>
</div>
</div>

								
							</div>
						</div>
					</div>
					
					<div class="yui-u">
						<div id="sidebar">
							
							<h2>EtoileFoundation</h2>
<ul>
<li><a href="README.html">Presentation</a></li>
<li><a href="INSTALL.Cocoa.html">Cocoa Installation</a></li>
<li><a href="INSTALL.GNUstep.html">GNUstep Installation</a></li>
<li><a href="NEWS.html">Revision History</a></li>
</ul>

<h3>Main</h3>
<ul>
<!-- Guides should be added here -->
<li><a href="APIOverview.html">API Overview</a></li>
</ul>

<!-- Uncomment if you want to add implementation or design notes here

<h3>Implementation</h3>
<ul>
<li><a href="DESIGN.html">Design</a></li>
<li><a href="TODO.html">Todo</a></li>
</ul> 

-->

<h3>C Symbols</h3>
<ul>
<li><a href="Functions.html">Functions</a></li>
<li><a href="Constants.html">Constants &amp; Global Variables</a></li>
<li><a href="Macros.html">Macros</a></li>
<li><a href="OtherDataTypes.html">Other Data Types</a></li>
</ul>

<h3>Classes</h3>
<div id="project-classes-list">
<ul><li><a href="ETAdaptiveModelObject.html#ETAdaptiveModelObject">ETAdaptiveModelObject</a></li><li><a href="ETByteSizeFormatter.html#ETByteSizeFormatter">ETByteSizeFormatter</a></li><li><a href="ETClassMirror.html#ETClassMirror">ETClassMirror</a></li><li><a href="ETCollectionTrait.html#ETCollectionTrait">ETCollectionTrait</a></li><li><a href="ETCollectionViewpoint.html#ETCollectionViewpoint">ETCollectionViewpoint</a></li><li><a href="ETCPrimitiveEntityDescription.html#ETCPrimitiveEntityDescription">ETCPrimitiveEntityDescription</a></li><li><a href="ETEntityDescription.html#ETEntityDescription">ETEntityDescription</a></li><li><a href="ETHistory.html#ETHistory">ETHistory</a></li><li><a href="ETIndexValuePair.html#ETIndexValuePair">ETIndexValuePair</a></li><li><a href="ETInstanceVariableMirror.html#ETInstanceVariableMirror">ETInstanceVariableMirror</a></li><li><a href="ETKeyValuePair.html#ETKeyValuePair">ETKeyValuePair</a></li><li><a href="ETListenSocket.html#ETListenSocket">ETListenSocket</a></li><li><a href="ETMethodDescriptionMirror.html#ETMethodDescriptionMirror">ETMethodDescriptionMirror</a></li><li><a href="ETMethodMirror.html#ETMethodMirror">ETMethodMirror</a></li><li><a href="ETModelDescriptionRepository.html#ETModelDescriptionRepository">ETModelDescriptionRepository</a></li><li><a href="ETModelElementDescription.html#ETModelElementDescription">ETModelElementDescription</a></li><li><a href="ETMultiOptionsRole.html#ETMultiOptionsRole">ETMultiOptionsRole</a></li><li><a href="ETMutableCollectionTrait.html#ETMutableCollectionTrait">ETMutableCollectionTrait</a></li><li><a href="ETMutableObjectViewpoint.html#ETMutableObjectViewpoint">ETMutableObjectViewpoint</a></li><li><a href="ETNumberRole.html#ETNumberRole">ETNumberRole</a></li><li><a href="ETObjectMirror.html#ETObjectMirror">ETObjectMirror</a></li><li><a href="ETPackageDescription.html#ETPackageDescription">ETPackageDescription</a></li><li><a href="ETPlugInRegistry.html#ETPlugInRegistry">ETPlugInRegistry</a></li><li><a href="ETPrimitiveEntityDescription.html#ETPrimitiveEntityDescription">ETPrimitiveEntityDescription</a></li><li><a href="ETPropertyDescription.html#ETPropertyDescription">ETPropertyDescription</a></li><li><a href="ETProtocolMirror.html#ETProtocolMirror">ETProtocolMirror</a></li><li><a href="ETReflection.html#ETReflection">ETReflection</a></li><li><a href="ETRelationshipRole.html#ETRelationshipRole">ETRelationshipRole</a></li><li><a href="ETRoleDescription.html#ETRoleDescription">ETRoleDescription</a></li><li><a href="ETSocket.html#ETSocket">ETSocket</a></li><li><a href="ETStackTrace.html#ETStackTrace">ETStackTrace</a></li><li><a href="ETStackTraceRecorder.html#ETStackTraceRecorder">ETStackTraceRecorder</a></li><li><a href="ETTranscript.html#ETTranscript">ETTranscript</a></li><li><a href="ETUnionViewpoint.html#ETUnionViewpoint">ETUnionViewpoint</a></li><li><a href="ETUTI.html#ETUTI">ETUTI</a></li><li><a href="ETUUID.html#ETUUID">ETUUID</a></li><li><a href="ETValidationResult.html#ETValidationResult">ETValidationResult</a></li><li><a href="ETViewpointTrait.html#ETViewpointTrait">ETViewpointTrait</a></li></ul></div>


<h3>Protocols</h3>
<div id="project-protocols-list">
<ul><li><a href="_ETClassMirror.html#ETClassMirror">ETClassMirror</a></li><li><a href="_ETCollection.html#ETCollection">ETCollection</a></li><li><a href="_ETCollectionHOM.html#ETCollectionHOM">ETCollectionHOM</a></li><li><a href="_ETCollectionHOMFilterIntegration.html#ETCollectionHOMFilterIntegration">ETCollectionHOMFilterIntegration</a></li><li><a href="_ETCollectionHOMIntegration.html#ETCollectionHOMIntegration">ETCollectionHOMIntegration</a></li><li><a href="_ETCollectionHOMMapIntegration.html#ETCollectionHOMMapIntegration">ETCollectionHOMMapIntegration</a></li><li><a href="_ETCollectionMutation.html#ETCollectionMutation">ETCollectionMutation</a></li><li><a href="_ETCollectionMutationHOM.html#ETCollectionMutationHOM">ETCollectionMutationHOM</a></li><li><a href="_ETInstanceVariableMirror.html#ETInstanceVariableMirror">ETInstanceVariableMirror</a></li><li><a href="_ETKeyedCollection.html#ETKeyedCollection">ETKeyedCollection</a></li><li><a href="_ETMethodMirror.html#ETMethodMirror">ETMethodMirror</a></li><li><a href="_ETMirror.html#ETMirror">ETMirror</a></li><li><a href="_ETObjectMirror.html#ETObjectMirror">ETObjectMirror</a></li><li><a href="_ETPropertyViewpoint.html#ETPropertyViewpoint">ETPropertyViewpoint</a></li><li><a href="_ETProtocolMirror.html#ETProtocolMirror">ETProtocolMirror</a></li><li><a href="_ETSocketFilter.html#ETSocketFilter">ETSocketFilter</a></li><li><a href="_ETTranscriptDelegate.html#ETTranscriptDelegate">ETTranscriptDelegate</a></li><li><a href="_ETViewpoint.html#ETViewpoint">ETViewpoint</a></li><li><a href="_ETViewpointMutation.html#ETViewpointMutation">ETViewpointMutation</a></li></ul></div>


<h3>Categories</h3>
<div id="project-categories-list">
<ul><li><a href="NSArrayCategories.html#NSArray(ETCollection)">NSArray</a></li><li><a href="NSCountedSetCategories.html#NSCountedSet(ETCollection)">NSCountedSet</a></li><li><a href="NSDataCategories.html#NSData(ETHash)">NSData</a></li><li><a href="NSDateCategories.html#NSDate(ETModel)">NSDate</a></li><li><a href="NSDictionaryCategories.html#NSDictionary(ETCollection)">NSDictionary</a></li><li><a href="NSExceptionCategories.html#NSException(ETException)">NSException</a></li><li><a href="NSFileHandleCategories.html#NSFileHandle(ETSocketAdditions)">NSFileHandle</a></li><li><a href="NSFileManagerCategories.html#NSFileManager(ETTempFile)">NSFileManager</a></li><li><a href="NSIndexPathCategories.html#NSIndexPath(Etoile)">NSIndexPath</a></li><li><a href="NSIndexSetCategories.html#NSIndexSet(ETCollection)">NSIndexSet</a></li><li><a href="NSInvocationCategories.html#NSInvocation(Etoile)">NSInvocation</a></li><li><a href="NSMapTableCategories.html#NSMapTable(Etoile)">NSMapTable</a></li><li><a href="NSMutableArrayCategories.html#NSMutableArray(ETCollectionHOM)">NSMutableArray</a></li><li><a href="NSMutableDictionaryCategories.html#NSMutableDictionary(ETCollectionHOM)">NSMutableDictionary</a></li><li><a href="NSMutableIndexSetCategories.html#NSMutableIndexSet(ETCollectionHOM)">NSMutableIndexSet</a></li><li><a href="NSMutableOrderedSetCategories.html#NSMutableOrderedSet(ETCollectionMutation)">NSMutableOrderedSet</a></li><li><a href="NSMutableSetCategories.html#NSMutableSet(ETCollectionHOM)">NSMutableSet</a></li><li><a href="NSNumberCategories.html#NSNumber(ETModel)">NSNumber</a></li><li><a href="NSObjectCategories.html#NSObject(ETBatchCollectionMutation)">NSObject</a></li><li><a href="NSOrderedSetCategories.html#NSOrderedSet(ETCollection)">NSOrderedSet</a></li><li><a href="NSSetCategories.html#NSSet(ETCollection)">NSSet</a></li><li><a href="NSStringCategories.html#NSString(ETBase64)">NSString</a></li><li><a href="NSUserDefaultsCategories.html#NSUserDefaults(ETUUID)">NSUserDefaults</a></li></ul></div>


							
						</div>
					</div>
					
				</div> <!-- yui-gc-content -->
				
			</div> <!--bd-team -->
			
			<div id="ft">
				<div id="bottom_nav">
					<a href="/store/">Store</a> | 
					<a href="/feeds/">RSS Feeds</a> | 
					<a href="/media/">Media Kit</a> | 
					<a href="/contact/">Contact Us</a>
				</div>
				<div id="legal">Copyright &copy; 2011 &Eacute;toil&eacute; Project. All rights reserved.</div>
			</div>
			
		</div> <!-- doc3-yui-t7 -->
		
		<div>
			<img src="/images/community/diagonals.gif" class="hidden"/>
			<img src="../images/developer/diagonals.gif" class="hidden"/>
			
			<img src="/images/news/diagonals.gif" class="hidden"/>
			<img src="/images/system/diagonals.gif" class="hidden"/>
			
			<img src="/images/community/growth.png" class="hidden"/>
			<img src="../images/developer/growth.png" class="hidden"/>
			<img src="/images/news/growth.png" class="hidden"/>
			<img src="/images/system/growth.png" class="hidden"/>
		</div>
		
	</body>
</html>
